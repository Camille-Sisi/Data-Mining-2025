{"title":"Systématiser nos procédures : construire une fonction","markdown":{"headingText":"Systématiser nos procédures : construire une fonction","headingAttr":{"id":"sec-Fonctions","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n```{r message=FALSE, warning=FALSE}\n# Chargement des librairies\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(janitor)\n\n# Chargement des tables\nRP_final <- readRDS(file = \"data/RP_final.Rdata\")\nmeta <- readRDS(file = \"data/meta.Rdata\")\n```\n\nPour ré-utiliser un code de façon plus automatique, créer des fonctions est très utile (et on peut même les stocker dans un fichier `.r` pour les réutiliser plus tard pour une autre étude).\n\n## Principes généraux d'une fonction\n\nL'idée est qu'à partir d'un bloc d'instructions ou de lignes de codes, on l'intègre dans une fonction qui portera un nom et qui pourra être appliquée sur les paramètres que l'on veut (table/objet différent, variables différentes) et qui nous retournera une valeur en sortie (qu'il faut préciser donc). Par exemple :\n\n```{r eval=FALSE}\n# Exemple fonction avec 3 arguments\nnom_fonction <- function(data, var1, var2) {\n  \n  expression...  # Ce que la fonction fait\n  \n  return()  # Optionnel, mais la plupart du temps utilisé (!), \n               # pour sortir le résultat de la fonction\n  \n}\n\n# L'appel de la fonction devra ainsi préciser la table de données sur laquelle \n# l'appliquer et les autres arguments : \nnom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1,  \n             var2 = nom_de_ma_variable2)\n\n# De plus, on pourra créer un nouvel objet (ici \"tab_var\") pour stocker la table \n# qui est en valeur de sortie de la fonction : \ntab_var <- nom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1,\n                        var2 = nom_de_ma_variable2)\n```\n\nLes arguments doivent donc être précisés en entrée de notre fonction, si on ne les précise pas cela nous retournera une erreur... à moins que l'on ait spécifié des valeurs par défaut (ce qui peut être utile si on utilise souvent les mêmes paramètres, par exemple la même base de données) ; il peut y avoir autant d'arguments que l'on souhaite.\n\nSi l'on utilise le langage tidyverse, il faut connaître quelques petits \"trucs\" pour écrire une fonction. Le schéma suivant réalisé par Julien Barnier du CNRS nous sera très utile.\n\n![Pour une fonction utilisant le langage tidyverse](images/Schéma%20tidyverse%20functions_Julien%20Barnier.jpg) *Source* : Julien Barnier, <a href=\"https://twitter.com/lapply/status/1493908215796535296?s=20&t=p4aYIEV4GsGS3TGftPa0Nw\" target=\"_blank\">https://twitter.com/lapply/status/1493908215796535296?s=20&t=p4aYIEV4GsGS3TGftPa0Nw</a>.\n\nVous trouverez également des informations utiles <a href=\"https://thinkr.fr/comment-creer-des-fonctions-dans-le-tidyverse-avec-la-tidyeval-et-le-stash-stash/\" target=\"_blank\">ici</a> ou <a href=\"https://www.vishalkatti.com/posts/2021-07-17-programmingwithdplyr/\" target=\"_blank\">là</a>.\n\n## Exemples de fonctions\n\nOn peut d'abord créer une fonction reprenant le code de la section précédente pour la construction de tableau. On l'appelle `tableau`, et on lui donne comme arguments \"data\", \"filtre_dept\", \"var_quali\", \"pond\" et \"nom_var_quali\".\n\nDans le langage tidyverse, au sein d'une fonction, il faut appeler une variable avec des doubles-accolades `{{  }}`.\n\nSi l'on utilise une fonction `summarise()`, une autre subtilité à connaître est que cette syntaxe `summarise({{ nom_var }} = mean({{ var }}, na.rm=TRUE))` ne sera pas reconnue, car il faut indiquer non pas un `=` mais un `:=` pour que la fonction puisse être lue lorsque le nom donné à la variable est de type caractère ou \"string\".\n\nEnfin, il ne faut pas oublier de retourner un objet en sortie avec `return()`.\n\nEssayez donc de créer une fonction `tableau()`, reprenant le premier code de la section précédente et remise ci-dessous pour information :\n\n```{r eval=FALSE}\nRP_final %>% \n  filter(DEPT == \"75\") %>% \n  mutate(SEXE_moda=case_when(SEXE==\"1\" ~ \"Hommes\", SEXE==\"2\" ~ \"Femmes\")) %>% #ne pas mettre cette ligne dans la fonction\n  count(SEXE_moda, wt=IPONDI) %>% \n  mutate(Pourcentage=round(prop.table(n)*100, 1)) %>% \n  adorn_totals(\"row\") %>% \n  rename(Effectif=n, 'Sexe'=SEXE_moda) %>% \n  gt() %>% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %>% \n  tab_header(title = \"Population par sexe en 2019\") %>% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n```{r message=FALSE}\ntableau <- function(data, filtre_dept, var_quali, pond=IPONDI, nom_var_quali){\n  \n  tab <- data %>% \n    filter(DEPT == filtre_dept) %>% \n    count({{ var_quali }}, wt={{ pond }}) %>% \n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %>% \n    adorn_totals(\"row\") %>% \n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n  \n  return(tab)\n  \n}\n```\n:::\n\n   \n\nOn peut vérifier qu'on obtient bien la même chose :\n\n```{r}\nRP_final %>% \n  mutate(SEXE_moda=case_when(SEXE==\"1\" ~ \"Hommes\", SEXE==\"2\" ~ \"Femmes\")) %>% \n  tableau(filtre_dept=\"75\", var_quali=SEXE_moda, nom_var_quali=\"Sexe\") %>% \n  gt() %>% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %>% \n  tab_header(title = \"Population par sexe en 2019\") %>% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n```\n\nOn a gagné 5 lignes de codes !\n\nSi on a plusieurs filtres à mettre, comme on a pu le voir avec le 2nd tableau, on peut utiliser l'argument \"...\" (lire \"dot\") : cet argument est très pratique si l'on ne sait pas combien il y aura de variable(s) dans la fonction à laquelle elle s'applique, c'est-à-dire autant 0 variable, 1 variable ou plus d'une variable ; mais elle peut aussi être \"dangereuse\" si on ne se souvient plus qu'on l'a créée et/ou si on ne fait pas attention à bien remplir les autres arguments avec les noms correspondants. Si on réécrit la fonction tableau et qu'on l'applique au 2nd tableau créé précédemment, cela donnerait ceci :\n\n```{r}\ntableau <- function(data, ..., var_quali, pond=IPONDI, nom_var_quali){\n  \n  tab <- data %>% \n    filter(...) %>% \n    count({{ var_quali }}, wt={{ pond }}) %>% \n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %>% \n    adorn_totals(\"row\") %>% \n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n  \n  return(tab)\n  \n}\n\nRP_final %>% \n  mutate(TACT_moda=case_when(TACT == \"11\" ~ \"Actifs ayant un emploi\",\n                             TACT == \"12\" ~ \"Chômeurs\",\n                             TACT == \"22\" ~ \"Élèves, étudiants et stagiaires non rémunérés\",\n                             TACT == \"21\" ~ \"Retraités ou préretraités\",\n                             TRUE ~ \"Autres inactifs\"),\n         TACT_moda=fct_relevel(TACT_moda, c(\"Actifs ayant un emploi\", \"Chômeurs\",\n                                            \"Élèves, étudiants et stagiaires non rémunérés\", \n                                            \"Retraités ou préretraités\", \"Autres inactifs\"))) %>% \n  tableau(DEPT == \"75\" & !AGEREVQ %in% c(\"0\", \"5\", \"10\", \"65\", \"70\", \"75\", \"80\", \"85\", \"90\", \"95\", \n                                        \"100\", \"105\", \"110\", \"115\", \"120\"),\n          var_quali=TACT_moda, nom_var_quali=\"Type d'activité\") %>% \n  gt() %>% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %>% \n  tab_header(title = \"Population de 15-64 ans par type d'activité en 2019\") %>% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n```\n\nUne autre façon de faire serait de créer un vecteur qui contiendrait ces différents filtres mais qu'il faudrait combiner dans une chaîne de caractères, ce qui est possible avec la fonction `paste0()`, et l'insérer ensuite dans la ligne de code `dplir` en utilisant `eval(parse(text=))` pour convertir cette chaîne de caractéres en une expression (`parse(text=)`) pour que `R` puisse l'évaluer/le calculer avec la fonction `eval()`.\n\n```{R, eval=FALSE}\ntableau_bis <- function(data, vars_filtre, var_quali, pond=IPONDI, nom_var_quali){\n\n  text_filtre <- paste0(\"(\", vars_filtre, \")\", collapse = \" & \")\n\n  tab1 <- data %>%\n    filter(eval(parse(text = text_filtre))) %>%\n    count({{ var_quali }}, wt={{ pond }}) %>%\n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %>%\n    adorn_totals(\"row\") %>%\n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n\n  return(tab1)\n\n}\n\n# Attention, comme les filtres sont contenues dans des \" \", il faut à l'intérieur des  \n#  filtres utiliser les ' ' plutôt que les \" \"\nmes_filtres <- c(\"DEPT == '75'\", \"!AGEREVQ %in% c('0', '5', '10', '65', '70', '75', \n                                                  '80', '85', '90', '95', '100', '105',\n                                                  '110', '115', '120')\")\n\nRP_final %>% \n  mutate(TACT_moda=case_when(TACT == \"11\" ~ \"Actifs ayant un emploi\",\n                             TACT == \"12\" ~ \"Chômeurs\",\n                             TACT == \"22\" ~ \"Élèves, étudiants et stagiaires non rémunérés\",\n                             TACT == \"21\" ~ \"Retraités ou préretraités\",\n                             TRUE ~ \"Autres inactifs\"),\n         TACT_moda=fct_relevel(TACT_moda1, c(\"Actifs ayant un emploi\", \"Chômeurs\",\n                                            \"Élèves, étudiants et stagiaires non rémunérés\", \n                                            \"Retraités ou préretraités\", \"Autres inactifs\"))) %>% \n  tableau_bis(mes_filtres, var_quali=TACT_moda, nom_var_quali=\"Type d'activité\") %>%\n  gt() %>%\n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %>% \n  tab_header(title = \"Population de 15-64 ans par type d'activité en 2019\") %>% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n```\n\nOn peut également créer une fonction pour permettre de récupérer plus rapidement les libellés des variables à partir du fichier de métadonnées :\n\n```{R}\n# Pour la fonction mutate, on est de nouveau obligé d'utiliser l'expression \n#  'eval(parse(text={{ cod_var }}))' sinon R ne comprend pas que la variable \n#  utilisée est une expression de type caractère\nlibelles_var <- function(data, cod_var, new_var){\n  \n  levels_var <- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD\n  labels_var <- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD\n  data %>% mutate({{ new_var }} := factor(eval(parse(text={{ cod_var }})), \n                                          levels = levels_var, labels = labels_var))\n\n}\n\n\n# Autre possibilité, utiliser la fonction `sym()` (qui crée un symbole à partir \n# d'une chaîne de caractères) avec les \"!!\" (opérateur bang-bang qui permet de \n# forcer l'évaluation d'une partie d'une expression avant le reste) : \n\n# libelles_var <- function(data, cod_var, new_var){\n#   \n#   levels_var <- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD\n#   labels_var <- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD\n#   data %>% mutate({{ new_var }} := factor(!!sym({{ cod_var }}), \n#                                           levels = levels_var, \n#                                           labels = labels_var))\n#   \n# }\n```\n\nEnfin, essayez d'écrire une seconde fonction `somme()` permettant de systématiser le code utilisée en fin de 1ère séance et qui donnait un tableau de contingence du nombre de personnes caractériées par son statut par commune (cela nous servira pour plus tard...) ; le voici pour rappel :\n\n```{r eval=FALSE}\nRP_final %>% \n  group_by(COM) %>%\n  count(TACT, wt=IPONDI) %>% \n  mutate(n=round(n)) %>% \n  pivot_wider(names_from = TACT, values_from = n)\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n```{r}\nsomme <- function(data, var_gpe, nom_var){\n  \n  som <- data %>% \n    group_by({{var_gpe}}) %>% \n    count({{nom_var}}, wt=IPONDI) %>% \n    mutate(n=round(n)) %>% \n    pivot_wider(names_from = {{nom_var}}, values_from = n)\n  \n  return(som)\n  \n}\n```\n:::\n\nVérifions :\n\n```{r}\nsomme(data=RP_final, COM, TACT)\n```\n\nLa création de fonctions est donc très utile pour avoir un code plus efficace ; il faut toutefois réfléchir à son usage avant de la créer pour savoir à quel point il faut systématiser les procédures utilisées, certains éléments devant être laissés probablement en-dehors de la fonction, comme dans l'exemple précédent le fait d'arrondir les chiffres. Il faut par ailleurs toujours vérfier, sur un ou deux exemples, que la fonction fonctionne bien, c'est-à-dire donne les mêmes résultats que le code initial.\n\nPour pouvoir les réutiliser ultérieurement, on peut les réécrire dans un nouveau script qu'on enregistre dans un dossier de notre projet qu'on intitule \"fonctions\" ; il suffira ensuite d'appeler ce programme avec la fonction `source()` :\n\n```{r eval=FALSE}\nsource(\"fonctions/fonctions.R\")\n```\n","srcMarkdownNoYaml":""},"formats":{"bookup-html":{"identifier":{"display-name":"HTML","target-format":"bookup-html","base-format":"html","extension-name":"bookup"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"filters":["F:\\Enseignements\\Enseignements Univ. Paris Cite 2020-xx\\Data Mining_M2 PISE\\Cours 2023-2025\\Data-Mining-2025\\_extensions\\juba\\bookup\\embed-fonts.lua"],"toc-depth":3,"output-file":"06-Fonctions.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.26","embed-fonts":true,"theme":{"light":["_extensions/juba/bookup/bookup.scss"],"dark":["_extensions/juba/bookup/bookup.scss","_extensions/juba/bookup/bookup_dark.scss"]},"revealjs-plugins":[],"toc-title":"Sur cette page"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["bookup-html"]}