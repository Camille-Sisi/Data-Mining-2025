[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Mining 2025",
    "section": "",
    "text": "Présentation",
    "crumbs": [
      "Présentation"
    ]
  },
  {
    "objectID": "index.html#à-propos-de-ce-document",
    "href": "index.html#à-propos-de-ce-document",
    "title": "Data Mining 2025",
    "section": "À propos de ce document",
    "text": "À propos de ce document\nCe document est la version 2025 du cours de Data Mining dispensé aux étudiants de deuxième année de l’option Data du master MECI parcours PISE et CCESE. Ce cours est partagé avec Claude Grasland.\nCe document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse suivante :\n\nhttps://github.com/Camille-Sisi/Data-Mining-2025.\n\nPour toute suggestion ou correction, n’hésitez pas à me contacter par mail.",
    "crumbs": [
      "Présentation"
    ]
  },
  {
    "objectID": "index.html#prérequis",
    "href": "index.html#prérequis",
    "title": "Data Mining 2025",
    "section": "Prérequis",
    "text": "Prérequis\nLe seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux.\nPour installer R, il suffit de se rendre sur une des pages suivantes1 :\n\nInstaller R sous Windows\nInstaller R sous Mac\n\nPour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système :\n\nhttps://www.rstudio.com/products/rstudio/download/#download",
    "crumbs": [
      "Présentation"
    ]
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "Data Mining 2025",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International.",
    "crumbs": [
      "Présentation"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Data Mining 2025",
    "section": "",
    "text": "Sous Linux, utilisez votre gestionnaire de packages habituel.↩︎",
    "crumbs": [
      "Présentation"
    ]
  },
  {
    "objectID": "01-Base-de-donnees.html",
    "href": "01-Base-de-donnees.html",
    "title": "1  Récupération de la base de données",
    "section": "",
    "text": "1.1 Les données du Recensement de la Population (RP)\nOn va travailler cette année sur les données du Recensement de la Population (RP). C’est une base de données riche en informations, qui s’appuie sur les enquêtes annuelles du recensement et est produite par l’Insee. Les fichiers mis à disposition sur leur site sont au nombre de 9 : ils rassemblent des informations différentes, sur des espaces géographiques différents (canton ou ville, région), et à des niveaux d’analyse différents (individus, ménages/logements). Les derniers fichiers disponibles portent sur l’année 2021 mais nous allons travailer sur l’année 2019 qui rassemble les enquêtes annuelles du recensement (EAR) des années 2017 à 2021.\nAvant de rentrer plus dans les détails, on va charger les librairies principales que l’on va utiliser lors de cette séance (si elles ne sont pas installées sur votre RStudio, il faut le faire avant en utilisant la commande install.packages(\"nom.du.package\"), on pourra en appeler d’autres dans les deux sections suivantes.\nOn va travailler plus précisément à partir du fichier “Individus localisés au canton-ou-ville” qui décrit les caractéristiques des individus et celles des ménages qui les occupent. Les données sont localisées au niveau de la commune et de l’IRIS. On ne va pas s’intéresser à l’ensemble de la France, pour des questions d’intérêt et d’analyse, ainsi que des questions pratiques (ces fichiers étant lourds). On va donc télécharger uniquement ce fichier pour la zone A, c’est-à-dire l’Île-de-France.\nLe mieux est de télécharger le fichier puis le dézipper directement dans R comme ci-dessous en copiant le lien URL sur le site de l’Insee ; et on le stock dans le dossier “data” de notre projet R. Sinon, il reste possible de le télécharger via internet et de l’enregistrer dans un de vos dossiers bien spécifiés pour le “dézipper” ensuite.\ndownload.file(url=\"https://www.insee.fr/fr/statistiques/fichier/6544333/RP2019_INDCVIZA_csv.zip\",\n              destfile = \"data/RP2019_INDCVIZA_csv.zip\")\n\n# Le fichier a donc été téléchargé dans le dossier intitulé \"data\" du projet R, on va\n# maintenant le dézipper et enregistrer les fichiers extraits dans le même dossier.\nunzip(\"data/RP2019_INDCVIZA_csv.zip\", exdir = \"data\")\nIl nous reste plus qu’à charger les données dans notre environnement RStudio : pour cela on utilise la commande fread du package data.table (à installer avant), car cela va bien plus vite que les fonctions habituelles du type read.csv lorsqu’on a de gros fichiers. On indique également l’option stringsAsFactors=TRUE pour que les variables caractères soient directement transformées en variables “factor” (dont l’utilité est indéniable dans R, on en reparlera plus loin), et on transforme l’objet obtenu en data.frame.\n# install.packages(\"data.table\")\nlibrary(data.table)\nRP &lt;- fread(\"data/FD_INDCVIZA_2019.csv\", stringsAsFactors=TRUE)\nRP &lt;- as.data.frame(RP)\nOn a donc 88 variables et 4 354 518 observations.\nPour se renseigner sur les variables de la table, on peut télécharger également le fichier des métadonnées avec la commande read.csv cette fois, ce qui nous permet de voir quelles options sont utiles ici : l’argument sep = nous permet d’indiquer comment sont séparées les informations dans le fichier initial, l’argument encoding = permet que les accents aigus soient compris par R comme tel, et enfin la même option stringsAsFactors=TRUE peut être utilisée ici.\n# Lecture du fichier de métadonnées\nmeta &lt;- read.csv(file = 'data/Varmod_INDCVI_2019.csv',\n                 sep = \";\",\n                 encoding = \"UTF-8\",\n                 stringsAsFactors = TRUE)\nOn peut enregistrer ce fichier, ainsi que celui contenant les métadonnées, dans le dossier R au format RDS.\n# Enregistrement des fichiers\nsaveRDS(object = RP, file = \"data/indiv2019.Rdata\")\nsaveRDS(object = meta, file = \"data/meta.Rdata\")",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Récupération de la base de données</span>"
    ]
  },
  {
    "objectID": "01-Base-de-donnees.html#quelles-informations-intéressantes-dans-cette-base",
    "href": "01-Base-de-donnees.html#quelles-informations-intéressantes-dans-cette-base",
    "title": "1  Récupération de la base de données",
    "section": "1.2 Quelles informations intéressantes dans cette base ?",
    "text": "1.2 Quelles informations intéressantes dans cette base ?\nOn peut regarder plus précisément les variables disponibles dans cette base de données à partir de la table de métadonnées : on peut le faire avec la fonction view() et dans ce cas la table s’affichera dans un nouvel onglet dans votre RStudio ; sinon pour l’afficher sur notre document notebook, on peut utiliser la fonction head() et/ou tail() qui affiche respectivement les premières lignes et les dernières lignes de la table.\n\n# view(meta)\nmeta %&gt;% head() %&gt;% gt() #La fonction gt() permet un affichage plus joli pour le document html\n\n\n\n\n\n\n\nCOD_VAR\nLIB_VAR\nCOD_MOD\nLIB_MOD\nTYPE_VAR\nLONG_VAR\n\n\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0101\nAmbérieu-en-Bugey (0101)\nCHAR\n5\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0102\nAttignat (0102)\nCHAR\n5\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0103\nValserhône (0103)\nCHAR\n5\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0104\nBelley (0104)\nCHAR\n5\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0105\nBourg-en-Bresse-1 (0105)\nCHAR\n5\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n0106\nBourg-en-Bresse-2 (0106)\nCHAR\n5\n\n\n\n\n\n\n\nOn peut établir la liste des variables de la base de données en utilisant la fonction levels qui donne les niveaux de la variable “COD_VAR” puisque c’est une variable ‘factor’.\n\nlevels(meta$COD_VAR) \n\n [1] \"ACHLR\"     \"AEMMR\"     \"AGED\"      \"AGER20\"    \"AGEREV\"    \"AGEREVQ\"  \n [7] \"ANAI\"      \"ANEMR\"     \"APAF\"      \"ARM\"       \"ASCEN\"     \"BAIN\"     \n[13] \"BATI\"      \"CANTVILLE\" \"CATIRIS\"   \"CATL\"      \"CATPC\"     \"CHAU\"     \n[19] \"CHFL\"      \"CHOS\"      \"CLIM\"      \"CMBL\"      \"COUPLE\"    \"CS1\"      \n[25] \"CUIS\"      \"DEPT\"      \"DEROU\"     \"DIPL\"      \"DNAI\"      \"EAU\"      \n[31] \"EGOUL\"     \"ELEC\"      \"EMPL\"      \"ETUD\"      \"GARL\"      \"HLML\"     \n[37] \"ILETUD\"    \"ILT\"       \"IMMI\"      \"INAI\"      \"INATC\"     \"INFAM\"    \n[43] \"INPER\"     \"INPERF\"    \"IPONDI\"    \"IRAN\"      \"IRIS\"      \"LIENF\"    \n[49] \"LPRF\"      \"LPRM\"      \"METRODOM\"  \"MOCO\"      \"MODV\"      \"NA17\"     \n[55] \"NA5\"       \"NAIDT\"     \"NBPI\"      \"NE17FR\"    \"NE24FR\"    \"NE3FR\"    \n[61] \"NE5FR\"     \"NENFR\"     \"NPERR\"     \"NUMF\"      \"NUMMI\"     \"ORIDT\"    \n[67] \"RECH\"      \"REGION\"    \"SANI\"      \"SANIDOM\"   \"SEXE\"      \"SFM\"      \n[73] \"STAT_CONJ\" \"STATR\"     \"STOCD\"     \"SURF\"      \"TACT\"      \"TACTD16\"  \n[79] \"TP\"        \"TRANS\"     \"TRIRIS\"    \"TYPC\"      \"TYPFC\"     \"TYPL\"     \n[85] \"TYPMC\"     \"TYPMR\"     \"VOIT\"      \"WC\"       \n\n\nLes codes des variables n’étant pas très parlant, on va les afficher avec leur intitulé : pour cela, il suffit de repartir de la table meta en sélectionnant les 2 colonnes qui nous intéressent et en n’affichant pas les valeurs dupliquées avec la fonction unique().\n\nmeta %&gt;% select(COD_VAR, LIB_VAR) %&gt;% unique() %&gt;% gt()\n\n\n\n\n\n\n\nCOD_VAR\nLIB_VAR\n\n\n\n\nCANTVILLE\nDépartement, canton-ou-ville du lieu de résidence (pseudo-canton)\n\n\nNUMMI\nNuméro du ménage dans le canton-ou-ville (anonymisé)\n\n\nACHLR\nPériode regroupée d'achèvement de la construction de la maison ou de l'immeuble\n\n\nAEMMR\nAnnée d'emménagement dans le logement (regroupée)\n\n\nAGED\nÂge détaillé (en différence de millésimes)\n\n\nAGER20\nÂge en années révolues (âge au dernier anniversaire) en 13 classes d'âge, détaillées autour de 20 ans\n\n\nAGEREV\nÂge en années révolues détaillé\n\n\nAGEREVQ\nÂge quinquennal en années révolues\n\n\nANAI\nAnnée de naissance\n\n\nANEMR\nAncienneté d'emménagement dans le logement (regroupée)\n\n\nAPAF\nAppartenance à une famille\n\n\nARM\nArrondissement municipal de résidence (Paris, Lyon et Marseille)\n\n\nARM\nArrondissement municipal de résidence (Paris,Lyon et Marseille)\n\n\nASCEN\nDesserte par un ascenseur\n\n\nBAIN\nBaignoire ou douche (DOM)\n\n\nBATI\nAspect du bâti (DOM)\n\n\nCATIRIS\nCatégorie de l'IRIS\n\n\nCATL\nCatégorie de logement\n\n\nCATPC\nCatégorie de population condensée\n\n\nCHAU\nMoyen de chauffage du logement (DOM)\n\n\nCHFL\nChauffage central du logement (France métropolitaine)\n\n\nCHOS\nChauffe-eau solaire (DOM)\n\n\nCLIM\nExistence d'au moins une pièce climatisée (DOM)\n\n\nCMBL\nCombustible principal du logement (France métropolitaine)\n\n\nCOUPLE\nDéclaration de vie en couple\n\n\nCS1\nCatégorie socioprofessionnelle en 8 postes\n\n\nCUIS\nCuisine intérieure avec évier (DOM)\n\n\nDEPT\nDépartement du lieu de résidence\n\n\nDEROU\nNombre de deux-roues à moteur du ménage (DOM)\n\n\nDIPL\nDiplôme le plus élevé\n\n\nDNAI\nDépartement de naissance (si né en France)\n\n\nEAU\nPoint d'eau potable à l'intérieur du logement (DOM)\n\n\nEGOUL\nMode d'évacuation des eaux usées (DOM)\n\n\nELEC\nÉlectricité dans le logement (DOM)\n\n\nEMPL\nCondition d'emploi\n\n\nETUD\nInscription dans un établissement d'enseignement\n\n\nGARL\nEmplacement réservé de stationnement\n\n\nHLML\nAppartenance du logement à un organisme HLM\n\n\nILETUD\nIndicateur du lieu d'études\n\n\nILT\nIndicateur du lieu de travail\n\n\nIMMI\nSituation quant à l'immigration\n\n\nINAI\nIndicateur du lieu de naissance\n\n\nINATC\nIndicateur de nationalité condensé (Français/Étranger)\n\n\nINFAM\nNombre de familles du ménage\n\n\nINPER\nNombre de personnes du ménage\n\n\nINPERF\nNombre de personnes de la famille\n\n\nIPONDI\nPoids de l'individu\n\n\nIRAN\nIndicateur de résidence antérieure au 1er janvier de l'année précédente\n\n\nIRIS\nCode IRIS du lieu de résidence\n\n\nLIENF\nLien familial\n\n\nLPRF\nLien à la personne de référence de la famille\n\n\nLPRM\nLien à la personne de référence du ménage\n\n\nMETRODOM\nIndicateur Métropole ou DOM du lieu de résidence\n\n\nMOCO\nMode de cohabitation\n\n\nMODV\nMode de vie\n\n\nNA17\nActivité économique en 17 postes (NA - A17)\n\n\nNA5\nActivité économique regroupée en 5 postes\n\n\nNAIDT\nNaissance dans un DOM-TOM-COM\n\n\nNBPI\nNombre de pièces du logement\n\n\nNE17FR\nNombre d'enfants âgés de 17 ans ou moins de la famille (regroupé)\n\n\nNE24FR\nNombre d'enfants âgés de 24 ans ou moins de la famille (regroupé)\n\n\nNE3FR\nNombre d'enfants âgés de 3 ans ou moins de la famille (regroupé)\n\n\nNE5FR\nNombre d'enfants âgés de 5 ans ou moins de la famille (regroupé)\n\n\nNENFR\nNombre d'enfants de la famille (regroupé)\n\n\nNPERR\nNombre de personnes du ménage (regroupé)\n\n\nNUMF\nNuméro de famille\n\n\nORIDT\nOriginaire d'un DOM-TOM-COM\n\n\nRECH\nAncienneté de recherche d'emploi\n\n\nREGION\nRégion du lieu de résidence\n\n\nSANI\nInstallations sanitaires (France métropolitaine)\n\n\nSANIDOM\nInstallations sanitaires (DOM)\n\n\nSEXE\nSexe\n\n\nSFM\nStructure familiale du ménage\n\n\nSTATR\nStatut professionnel regroupé\n\n\nSTAT_CONJ\nStatut conjugal\n\n\nSTOCD\nStatut d'occupation détaillé du logement\n\n\nSURF\nSuperficie du logement\n\n\nTACT\nType d'activité\n\n\nTACTD16\nType d'activité détaillé en 16 postes\n\n\nTP\nTemps de travail\n\n\nTRANS\nMode de transport principal le plus souvent utilisé pour aller travailler\n\n\nTRIRIS\nCode TRIRIS du lieu de résidence\n\n\nTYPC\nType de construction\n\n\nTYPFC\nType de famille condensé\n\n\nTYPL\nType de logement\n\n\nTYPMC\nType de ménage regroupé (en 4 postes)\n\n\nTYPMR\nType de ménage regroupé (en 9 postes)\n\n\nVOIT\nNombre de voitures du ménage\n\n\nWC\nPrésence de W.-C. à l'intérieur du logement (DOM)\n\n\n\n\n\n\n\nOu si on veut les afficher par ordre alphabétique selon le nom de la variable, on peut utiliser la fonction arrange() qui permet de trier une table de données selon la variable indiquée :\n\nmeta %&gt;% select(COD_VAR, LIB_VAR) %&gt;% unique() %&gt;% arrange(COD_VAR) %&gt;% gt()\n\nL’une des difficultés pour l’analyse de cette base de données réside dans les différents niveaux présents : “individu” pour la personne de référence du ménage ; “ménage” regroupant l’ensemble des occupants d’une résidence principale, qu’ils aient ou non des liens de parenté ; “famille” partie d’un ménage comprenant au moins 2 personnes (par exemple, un couple, ou un adulte avec un enfant…) ; et enfin “logement” qui comprend ici les résidences principales et rassemble des informations décrivant les types de logement.\nIl faut bien comprendre comment utiliser à bon escient ces différents niveaux, en particulier ici le niveau logement : pour toute variable de ce niveau, il faudra utiliser un filtre, c’est-à-dire ne prendre que la personne de référence du ménage (LPRM==\"1\").\nIl faut également penser que les données sont pondérées, donc pour sortir des statistiques descriptives, il faut à chaque fois mettre la variable de pondération IPONDI.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Récupération de la base de données</span>"
    ]
  },
  {
    "objectID": "02-Manipulation-base.html",
    "href": "02-Manipulation-base.html",
    "title": "2  Manipulation de la base",
    "section": "",
    "text": "2.1 Format des données - WIDE ou LONG\nOn peut maintenant regarder à quoi ressemble la table principale, celle des données.\nLa fonction str() ou son équivalent en langage dplyr la fonction glimpse nous donne la liste des variables avec cette fois leur format et leurs modalités (les premières seulement s’il y en a beaucoup).\nLes variables sont en format, soit ‘int’ (“integer” - nombres entiers), soit ‘fct’ (“factor”), ou encore ‘dbl’ (“double” - nombres réels). On remarque que la plupart des variables ont des modalités en chiffres et/ou lettres, ce qui signifie qu’il faudra probablement recoder ces modalités pour leur donner des libellés dans nos analyses descriptives (tableaux ou graphiques).\nPar ailleurs, certaines variables ont été laissées en format ‘integer’ bien que l’on avait mis l’option stringsAsFactors=TRUE lors du chargement des données, or ces chiffres correspondent bien à des modalités d’une variable catégorielle, il faudra donc le corriger ultérieurement.\nDernière remarque, si on avait eu des valeurs manquantes sur certaines variables, elles se seraient ici affichées avec la modalité NA, cela ne semble pas le cas, à vérifier par la suite. En revanche, on voit parfois des modalités “z” ou “zz”, il faudra vérifier ce qu’elles indiquent.\nLa question du format de la table de données est importante, on distingue généralement le format wide du format long :\nIci, chaque ligne correspond à un individu auquel est associé un logement, un ménage ou encore une famille ; on est bien dans un format wide. L’unité statistique de base est donc l’individu, mais on peut vouloir choisir de se mettre au niveau logement ou ménage ou famille, pour étudier les caractéristiques de ces unités. Autre exemple, on peut aussi considérer que notre niveau d’analyse est la commune, on verra alors qu’on dispose de plusieurs lignes par commune et si l’on veut garder quelques informations à ce niveau en n’ayant plus qu’une ligne par commune, il faudra sommer ces informations.\nLe package tidyverse contient deux fonctions qui permettent de passer d’un format à un autre : pivot_longer() et pivot_wider() présentés en détails ici. Nous aurons l’occasion de les utiliser ultérieurement dans ce cours.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipulation de la base</span>"
    ]
  },
  {
    "objectID": "02-Manipulation-base.html#format-des-données---wide-ou-long",
    "href": "02-Manipulation-base.html#format-des-données---wide-ou-long",
    "title": "2  Manipulation de la base",
    "section": "",
    "text": "le premier renvoie au cas où chaque ligne correspond a un et un seul individu (ou autre niveau de l’analyse : une entreprise, un ménage, un logement, etc.), et toutes les informations le concernant sont données en colonnes (ce qui peut augmenter rapidement le nombre de colonnes), c’est l’exemple d’une information que l’on a sur plusieurs années, chaque colonne correspondant à l’information de l’année en question ;\nle second, au contraire, multiplie les lignes pour un seul individu, mais il y a alors moins de colonnes, à partir du même exemple précédent, il y aura cette fois une colonne indiquant l’année et une colonne contenant l’information.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipulation de la base</span>"
    ]
  },
  {
    "objectID": "02-Manipulation-base.html#sélectionner-un-champ-réduit-de-la-base-séparer-les-données",
    "href": "02-Manipulation-base.html#sélectionner-un-champ-réduit-de-la-base-séparer-les-données",
    "title": "2  Manipulation de la base",
    "section": "2.2 Sélectionner un champ réduit de la base, séparer les données",
    "text": "2.2 Sélectionner un champ réduit de la base, séparer les données\nManipuler une base de données, c’est aussi travailler ou créer une table réduite, surtout quand on a des données volumineuses comme ici : c’est donc choisir un champ particulier de la base.\nOn peut par exemple choisir un champ géographique plus réduit au sein de l’Île-de-France, à partir de la commune : Paris et sa petite couronne.\nOn peut aussi choisir de séparer les données en créant 2 tables selon l’unité statistique : l’individu ; ou le logement avec la seule personne de référence du ménage.\nComme vous le savez très probablement, dans le langage tidyverse, pour faire des sélections sur les lignes ou observations dans une table de données, on utilise la fonction filter() ; pour faire des sélections sur les colonnes ou variables, on utilise la fonction select() ; pour supprimer des variables, on utilise également select() avec un “-” devant la (ou les) variable(s) à supprimer (dans le langage R de base, on peut aussi utiliser la fonction subset()).\nEXERCICES : Créer trois nouvelles bases selon les indications suivantes :\n\nla première que vous nommerez “RP_Paris” et qui rassemblera les données pour le seul département de Paris ;\nla deuxième que nous nommerez “RP_indiv” et qui comprendra les données pour les seules variables décrivant l’individu (et ce sera celle de la personne de référence du ménage) ;\nla troisième que vous nommerez “RP_final”, qui rassemblera les données pour les départements de Paris et de sa petite couronne, et qui comprendra toutes les variables décrivant l’individu, le logement et enfin les variables géographiques.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nRP_Paris &lt;- RP %&gt;% filter(DEPT == \"75\")\n\nRP_indiv &lt;- RP %&gt;% select(\"AEMMR\", \"AGED\", \"AGER20\", \"AGEREV\",\"AGEREVQ\",\"ANAI\",\n                          \"ANEMR\",\"APAF\",\"COUPLE\",\"CS1\",\"DIPL\",\"DNAI\",\"EMPL\",\n                          \"ETUD\",\"ILETUD\",\"ILT\",\"IMMI\",\"INAI\",\"INATC\",\"IPONDI\",\n                          \"IRAN\",\"LPRF\",\"LPRM\",\"MOCO\",\"MODV\",\"NA17\",\n                          \"NA5\",\"NAIDT\",\"ORIDT\",\"RECH\",\"SEXE\",\"STAT_CONJ\",\n                          \"STATR\",\"TACT\",\"TACTD16\",\"TP\",\"TRANS\")\n  \nRP_final  &lt;- RP %&gt;% filter(DEPT %in% c(\"75\",\"92\",\"93\",\"94\")) %&gt;% \n                        select(-c(\"NUMMI\",\"INPERF\",\"DEROU\",\"LIENF\",\"INFAM\",\n                                  \"NE17FR\",\"INPER\", \"NE24FR\",\"NPERR\",   \"NE3FR\",\n                                  \"SFM\",    \"NE5FR\", \"TYPMC\",   \"NENFR\",\"TYPMR\",\n                                  \"NUMF\",\"VOIT\",    \"TYPFC\"))\n\n\n\n\nOn va dorénavant travailler sur cette dernière table RP_final, on l’enregistre donc dans notre dossier “data”, ainsi que le fichier meta que nous avons modifié précédemments :\n\n# Enregistrement des fichiers\nsaveRDS(object = RP_final , file = \"data/RP_final.Rdata\") \nsaveRDS(object = meta, file = \"data/meta.Rdata\")",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipulation de la base</span>"
    ]
  },
  {
    "objectID": "03-Manipulation-variables.html",
    "href": "03-Manipulation-variables.html",
    "title": "3  Manipulation des variables",
    "section": "",
    "text": "3.1 Manipulation des variables qualitatives\nDans la manipulation des variables, l’une des premières choses à réaliser est de les définir dans le bon format, variables quantitatives/continues ou variables qualitatives/catégorielles.\nOn l’a vu dans la section précédente, certaines variables sont encore codées comme des nombres entiers (“integer”) alors que ce sont des variables catégorielles. On va donc corriger cela en regardant d’abord quelles variables sont concernées, en les sélectionnant avec select_if() ou select(where()) :\nA part les variables d’âge AGED et AGEREV, de date de naissance ANAI et de pondération IPONDI, toutes les autres variables devraient en format “factor”. Deux façons de les transformer, soit vous changer les variables une à une en utilisant les fonctions mutate() et as.factor() ; soit vous créer une liste avec le nom des variables dont le format doit être transformer et vous utilisez la fonction lapply() en l’appliquant à cette liste de variables :\nOn peut ensuite vérifier que ces variables sont bien des variables facteurs en regardant combien de modalités elles ont et quelles sont-elles. Par exemple, pour la variable CATPC :\nSi nous n’avions pas mis l’option transformant les variables caractères en variables facteurs lors du chargement des données, nous pourrions le faire maintenant en utilisant la fonction mutate_if ou la combinaison de mutate et across(where()) comme ceci RP %&gt;% mutate_if(is.character, as.factor) ou RP %&gt;% mutate(across(.cols = where(is.character), .fns = as.factor)).\nOn peut enfin vérifier quelles sont les variables numériques qui restent :\nPlus généralement, il est souvent d’usage d’utiliser la fonction summary() pour donner un aperçu de l’ensemble des variables, soit de leur distribution pour les variables quantitatives, soit de leur répartition par modalités pour les variables qualitatives ; la fonction permet également de nous donner l’information sur l’existence et le nombre de valeurs manquantes pour chaque variable.\nMais attention, le problème ici est que cela nous donne des fréquences non pondérées pour l’ensemble de nos variables qualitatives, donc qui n’ont finalement pas grand sens.\nOn peut d’abord travailler sur les variables qualitatives qui correspondent ici à l’essentiel de nos variables.\nComme on le sait, on peut regarder les différents niveaux pour chacune d’entre elles, avec la fonction levels(). Si on veut appliquer la fonction à l’ensemble de nos variables facteurs sans avoir donc à les indiquer une par une, on peut avoir recours à la fonction sapply() qui permet d’appliquer la fonction indiquée entre parenthèses (ici levels()) à tous les éléments de notre table de données.\n# Pour info, ici cela s'écrirait : \nRP_final %&gt;% select(where(is.factor)) %&gt;% sapply(levels)\n# on peut même se passer de la sélection sur les variables :\n# RP %&gt;% sapply(levels)\nOn peut ensuite vouloir retravailler les modalités de ces variables, car par exemple les modalités ne sont pas parlantes puisque nommées par des codes chiffres, ou parce que les modalités sont trop nombreuses et qu’on souhaiterait les rassembler pour une analyse ultérieure.\nPar exemple, si l’on veut étudier la répartition de la population francilienne selon leur statut d’activité, on peut utiliser la variable TACT:\nlevels(RP_final$TACT)\n\n[1] \"11\" \"12\" \"21\" \"22\" \"23\" \"24\" \"25\"\nMais le moins qu’on puisse dire c’est que les 7 modalités de cette variable ne sont pas parlantes, on peut donc recoder les modalités de cette variable dans une étape préalable DATA comme ici ; on pourra bien sûr enchaîner plus tard les lignes de codes et réaliser cette étape dans une même procédure avec le tableau ou le graphique représentant cette variable.\nCommençons ici par l’étape DATA :\n# On cherche à quoi correspondent les modalités chiffrées de cette variable\n# dans le fichier \"meta\"\nmeta %&gt;% filter(COD_VAR==\"TACT\") %&gt;% select(COD_MOD, LIB_MOD)\n\n  COD_MOD\n1      11\n2      12\n3      21\n4      22\n5      23\n6      24\n7      25\n                                                                     LIB_MOD\n1 Actifs ayant un emploi, y compris sous apprentissage ou en stage rémunéré.\n2                                                                   Chômeurs\n3                                                  Retraités ou préretraités\n4               Élèves, étudiants, stagiaires non rémunéré de 14 ans ou plus\n5                                                            Moins de 14 ans\n6                                                  Femmes ou hommes au foyer\n7                                                            Autres inactifs\n# On recode à partir de ces libellés, tout en regroupant certaines modalités\n# qui sont très spécifiques et nous intéressent moins :\nRP_final &lt;- RP_final %&gt;% mutate(TACT_moda = as.factor(\n  case_when(TACT == \"11\" ~ \"Actifs en emploi\",\n            TACT == \"12\" ~ \"Chômeurs\",\n            TACT == \"21\" ~ \"Retraités\",\n            TACT %in% c(\"22\",\"23\",\"24\",\"25\") ~ \"Autres inactifs\")))\nlevels(RP_final$TACT_moda)\n\n[1] \"Actifs en emploi\" \"Autres inactifs\"  \"Chômeurs\"         \"Retraités\"\nSi l’on veut changer l’ordre des modalités, qui s’afficheront comme ci-dessus dans un tableau ou un graphique, on peut utiliser la fonction fct_relevel() du package forcats (à installer avant puis à appeler avant de l’utiliser) :\n# install.package(\"forcats\")\nlibrary(forcats)\nRP_final &lt;- RP_final %&gt;% mutate(TACT_moda = \n                                  fct_relevel(TACT_moda, \n                                              c(\"Actifs en emploi\",\"Chômeurs\",\n                                                \"Retraités\", \"Autres inactifs\")))\nlevels(RP_final$TACT_moda)\n\n[1] \"Actifs en emploi\" \"Chômeurs\"         \"Retraités\"        \"Autres inactifs\"\nPlus largement, pour travailler sur des variables qualitatives en particulier lorsqu’elles sont en format facteur, le package forcats est très utile. Outre une fonction de transformation d’une variable caractère en facteur (as_factor() proche de la version de baseR as.factor() utilisée en début de section), elle contient plein d’autres fonctions : fct_collapse() utilisée pour renommer ou regrouper des modalités d’une variable (au lieu de la double fonction as.factor() et case_when()) ; fct_relevel() utilisée également au-dessus pour trier les modalités comme on le souhaite ; fct_drop() pour enlever des niveaux de facteurs vides/sans effectifs ; fct_explicit_na() pour rendre les NA explicites en créant une modalité “(missing)” ; fct_reorder() et fct_reorder2() pour réordonner les modalités d’une variable, très utile pour les graphiques car utilisables directement dans ggplot() ; fct_lump() pour regrouper les modalités les plus communes (ou au contraire les moins communes) en lui indiquant entre parenthèses le nombre n= de modalités souhaitées ou la proportion minimum souhaitée prop=, et en sélectionnant la variable avec la fonction pull() avant car elle doit être en format vecteur et non data.frame ; ou encore fct_recode() pour changer le niveau des facteurs ; fct_other() ; fct_infreq() et fct_inorder() ; etc. Un bon récapitulatif de ces fonctions est présenté ici.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation des variables</span>"
    ]
  },
  {
    "objectID": "03-Manipulation-variables.html#manipulation-des-variables-quantitatives",
    "href": "03-Manipulation-variables.html#manipulation-des-variables-quantitatives",
    "title": "3  Manipulation des variables",
    "section": "3.2 Manipulation des variables quantitatives",
    "text": "3.2 Manipulation des variables quantitatives\nComme nous l’avons vu plus haut, il y a peu de variables quantitatives dans cette base et l’une d’entre elles est la pondération, donc on va regarder plus précisément la variable AGED. Cependant, celle-ci aussi est particulière car c’est une variable numérique constituée d’entiers naturels (et non de valeurs réelles) qui vont de 0 à 120 ; dans le fichier des métadonnées (ou le dictionnaire des variables disponible également sur le site de l’Insee), on se rend compte que la variable a été pensée comme catégorielle avec des modalités d’abord codées comme “000”, “001”, etc.\n\nmeta %&gt;% filter(COD_VAR==\"AGED\") %&gt;% select(COD_MOD, LIB_MOD) %&gt;% tail()\n\n    COD_MOD LIB_MOD\n116     115 115 ans\n117     116 116 ans\n118     117 117 ans\n119     118 118 ans\n120     119 119 ans\n121     120 120 ans\n\n\nOn peut alors regarder rapidement la distribution de cette variable.\n\nsummary(RP_final$AGED)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   21.00   36.00   38.44   55.00  120.00 \n\n\nOn peut aussi construire des variables continues en agrégeant certaines informations au niveau des communes par exemple. Reprenons la variable d’activité dont nous avons recoder et regrouper les modalités et calculons-là pour avoir le nombre de chaque modalité par commune. Il faut pour cela créer la variable de commune, qu’on appelera COM, à partir de l’IRIS :\n\nRP_final &lt;- RP_final %&gt;% mutate(COM=substr(IRIS, 1, 5))\n\nOn va ensuite sommer chaque modalité de la variable TACT_moda en utilisant la pondération en groupant par commune.\nEXERCICE :\nCréer donc un tableau qui aura 3 colonnes COM, TACT_moda et n. Vous pouvez utiliser les fonctions group_by suivi soit de count, soit de summarise ; on cherchera finalement à arrondir ces valeurs à l’unité avec la fonction round(). Vous devez obtenir le tableau suivant :\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nTab_com_TACT &lt;- RP_final %&gt;% group_by(COM) %&gt;%\n  count(TACT_moda, wt=IPONDI) %&gt;% \n  mutate(n=round(n))\n\n# RP_final %&gt;% group_by(COM, TACT_moda) %&gt;% \n#   summarise(n=sum(IPONDI)) %&gt;% \n#   mutate(n=round(n))\n\n\n\n\nOn voit qu’on a un tableau dans un format “long” puisqu’il y a plusieurs observations pour une seule commune. On va utiliser la fonction pivot_wider() mentionnée précédemment pour n’avoir qu’une ligne par commune et en colonne les types de statut avec leur nombre respectif.\n\nTab_com_TACT &lt;- Tab_com_TACT %&gt;% \n                   pivot_wider(names_from = TACT_moda, values_from = n)\nTab_com_TACT\n\n# A tibble: 137 × 5\n# Groups:   COM [137]\n   COM   `Actifs en emploi` Chômeurs Retraités `Autres inactifs`\n   &lt;chr&gt;              &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;             &lt;dbl&gt;\n 1 75101               8366      941      2630              3979\n 2 75102              13118     1378      2148              4964\n 3 75103              19239     2085      4589              8123\n 4 75104              15227     1863      4508              7513\n 5 75105              27378     2611     10607             17618\n 6 75106              18073     1842      8180             12176\n 7 75107              23394     2165      9573             13735\n 8 75108              18254     1565      5297             10534\n 9 75109              34155     3482      7264             15125\n10 75110              46454     6343     10645             23078\n# ℹ 127 more rows\n\n\n\n3.2.1 Détecter et “visualiser” les valeurs manquantes\nPour travailler sur les valeurs manquantes et valeurs aberrantes de variables quantitatives, on va s’appuyer sur une autre base de données, plus pertinente pour cela. Vous la trouverez sur l’espace de cours sur Moodle : il s’agit d’une extraction de la base de données JOCAS de la Dares (cf. ici) qui compile les offres d’emploi de l’année 2020 à partir de laquelle nous avons sélectionné les offres provenant de Pôle emploi (nouvellement France Travail) pour les communes de Paris et sa petite couronne.\nUne fois copiée dans le dossier “data/” du projet R, ouvrons cette base de données et commençons l’exploration de ses variables et de leurs valeurs manquantes :\n\nOffresPE_2020 &lt;- readRDS(file =\"data/OffresPE_2020.Rdata\")\nOffresPE_2020 %&gt;% head() %&gt;% gt()\n\n\n\n\n\n\n\ndate_firstSeenDay\ndate_scraping\ndate_sitePublicationDay\njob_title\njob_ROME_code\njob_qualification\ncontractType\ncontractDuration_min\ncontractDuration_max\ncontractDuration_period\ncontractDuration_value\nworkTime_hours\nworkTime_category\nworkTime_value\nlocation_label\nlocation_zipcode\nlocation_departement\nsalary_min\nsalary_max\nsalary_period\nsalary_value\nsalary_hourly_mean\nsalary_hourly_min\nsalary_hourly_max\nentreprise_nom\nentrepriseSecteur_NAF88\nentrepriseSecteur_NAF21\nteleworking_mentioned\nexperience_min\nexperience_max\neducation_level\n\n\n\n\n2020-01-01\nThu Jan 02 14:06:14 2020\n2020-01-01\nMénagère/ménager à domicile (H/F)\nK1304\nNA\nCDD\n6\n6\nMONTH\n130\n\n\nNA\nPARIS 02\n75002\n75\nNA\nNA\n\nNA\nNA\nNA\nNA\nParticulier Employeur\n97\nT\nFALSE\n0\nNA\n[]\n\n\n2020-01-01\nThu Jan 02 14:06:14 2020\n2020-01-01\nDessinateur / Dessinatrice d'exécution du BTP (H/F)\nF1104\n9\nCDI\nNA\nNA\n\nNA\n35H\nFULL_TIME_INFER\n35\nPUTEAUX\n92800\n92\n28000\n32000\nYEAR\n18.67\n18.67\n17.43\n19.92\nHuman Talent\nNA\n\nFALSE\n1\nNA\n[]\n\n\n2020-01-01\nThu Jan 02 14:06:14 2020\n2020-01-01\nSecrétaire juridique (H/F)\nM1607\n9\nCDI\nNA\nNA\n\nNA\n35H\nFULL_TIME_INFER\n35\nISSY LES MOULINEAUX\n92130\n92\n30000\n42000\nYEAR\n22.41\n22.41\n18.67\n26.14\nProJob Carrières\nNA\n\nFALSE\n3\nNA\n['Bac+2 ou équivalents']\n\n\n2020-01-01\nThu Jan 02 14:06:15 2020\n2020-01-01\nGarde d'enfant à domicile (H/F)\nK1303\nNA\nCDD\n9\n9\nMONTH\n195\n\n\nNA\nPARIS 10\n75010\n75\nNA\nNA\n\nNA\nNA\nNA\nNA\nParticulier Employeur\n97\nT\nFALSE\n0\nNA\n[]\n\n\n2020-01-01\nThu Jan 02 14:06:15 2020\n2020-01-01\nBaby-sitter (H/F)\nK1303\nNA\nCDD\n2\n2\nMONTH\n43\n\n\nNA\nPARIS 17\n75017\n75\nNA\nNA\n\nNA\nNA\nNA\nNA\nParticulier Employeur\n97\nT\nFALSE\n0\nNA\n[]\n\n\n2020-01-01\nThu Jan 02 14:06:15 2020\n2020-01-01\nBaby-sitter (H/F)\nK1303\nNA\nCDD\n8\n8\nMONTH\n173\n\n\nNA\nJOINVILLE LE PONT\n94340\n94\nNA\nNA\n\nNA\nNA\nNA\nNA\nParticulier Employeur\n97\nT\nFALSE\n0\nNA\n[]\n\n\n\n\n\n\nsummary(OffresPE_2020)\n\n date_firstSeenDay    date_scraping      date_sitePublicationDay\n Min.   :2020-01-01   Length:420523      Min.   :2020-01-01     \n 1st Qu.:2020-03-09   Class :character   1st Qu.:2020-03-09     \n Median :2020-06-29   Mode  :character   Median :2020-06-29     \n Mean   :2020-06-18                      Mean   :2020-06-18     \n 3rd Qu.:2020-09-16                      3rd Qu.:2020-09-16     \n Max.   :2020-12-31                      Max.   :2020-12-31     \n                                                                \n  job_title         job_ROME_code      job_qualification contractType      \n Length:420523      Length:420523      Min.   :1.00      Length:420523     \n Class :character   Class :character   1st Qu.:6.00      Class :character  \n Mode  :character   Mode  :character   Median :7.00      Mode  :character  \n                                       Mean   :6.78                        \n                                       3rd Qu.:8.00                        \n                                       Max.   :9.00                        \n                                       NA's   :305296                      \n contractDuration_min contractDuration_max contractDuration_period\n Min.   : 1.0         Min.   : 1.0         Length:420523          \n 1st Qu.: 3.0         1st Qu.: 3.0         Class :character       \n Median : 6.0         Median : 6.0         Mode  :character       \n Mean   : 8.5         Mean   : 8.5                                \n 3rd Qu.:10.0         3rd Qu.:10.0                                \n Max.   :99.0         Max.   :99.0                                \n NA's   :328334       NA's   :328334                              \n contractDuration_value workTime_hours     workTime_category  workTime_value  \n Min.   :    1.0        Length:420523      Length:420523      Min.   : 1.0    \n 1st Qu.:   65.0        Class :character   Class :character   1st Qu.:35.0    \n Median :  130.0        Mode  :character   Mode  :character   Median :35.0    \n Mean   :  147.6                                              Mean   :31.3    \n 3rd Qu.:  195.0                                              3rd Qu.:35.0    \n Max.   :20656.0                                              Max.   :56.0    \n NA's   :328383                                               NA's   :332206  \n location_label     location_zipcode location_departement   salary_min    \n Length:420523      Min.   :75000    Length:420523        Min.   :     3  \n Class :character   1st Qu.:75006    Class :character     1st Qu.:  1550  \n Mode  :character   Median :92150    Mode  :character     Median :  2165  \n                    Mean   :86066                         Mean   : 14480  \n                    3rd Qu.:93120                         3rd Qu.: 30000  \n                    Max.   :95926                         Max.   :500000  \n                    NA's   :68798                         NA's   :319455  \n   salary_max     salary_period       salary_value     salary_hourly_mean\n Min.   :     7   Length:420523      Min.   :    0.2   Min.   :    0.2   \n 1st Qu.:  2000   Class :character   1st Qu.:   11.5   1st Qu.:   11.6   \n Median :  3700   Mode  :character   Median :   14.8   Median :   15.0   \n Mean   : 21255                      Mean   :   20.1   Mean   :   20.1   \n 3rd Qu.: 39000                      3rd Qu.:   21.0   3rd Qu.:   21.2   \n Max.   :500000                      Max.   :40200.0   Max.   :40200.0   \n NA's   :352552                      NA's   :319923    NA's   :319923    \n salary_hourly_min salary_hourly_max entreprise_nom     entrepriseSecteur_NAF88\n Min.   :    0.1   Min.   :    0.2   Length:420523      Min.   : 1.00          \n 1st Qu.:   11.1   1st Qu.:   13.7   Class :character   1st Qu.:70.00          \n Median :   13.9   Median :   17.8   Mode  :character   Median :78.00          \n Mean   :   18.1   Mean   :   24.4                      Mean   :74.44          \n 3rd Qu.:   19.8   3rd Qu.:   24.9                      3rd Qu.:85.00          \n Max.   :39600.0   Max.   :40800.0                      Max.   :99.00          \n NA's   :319923    NA's   :352834                       NA's   :285597         \n entrepriseSecteur_NAF21 teleworking_mentioned experience_min  \n Length:420523           Mode :logical         Min.   : 0.000  \n Class :character        FALSE:417778          1st Qu.: 0.000  \n Mode  :character        TRUE :2745            Median : 0.000  \n                                               Mean   : 1.137  \n                                               3rd Qu.: 2.000  \n                                               Max.   :35.000  \n                                               NA's   :316     \n experience_max   education_level   \n Min.   : 0.2     Length:420523     \n 1st Qu.: 2.0     Class :character  \n Median : 5.0     Mode  :character  \n Mean   : 4.5                       \n 3rd Qu.: 5.0                       \n Max.   :99.0                       \n NA's   :381324                     \n\n\nAvec le head(), on remarque néanmoins que certaines variables ont des cellules vides (sans valeur ni ‘NA’), ce sont également des valeurs manquantes, c’est par exemple le cas pour la variable ‘contractDuration_period’, nous verrons après si les packages gérant les valeurs manquantes détectent également ces cellules vides.\nLa fonction summary() permet donc de donner une première information sur les valeurs manquantes des différentes variables. Pour se concentrer sur cette seule information, on peut compter le nombre de valeurs manquantes NA pour chacune des variables avec la fonction colSums() ; pour les avoir en proportion du nombre total d’observations (lignes), on peut utiliser la fonction colMeans() ; sinon, on peut utiliser la fonction summarise combinée avec across(where()), ) si l’on veut sélectionner uniquement les variables numériques et leur appliquer la fonction sommant les NA :\n\ncolSums(is.na(OffresPE_2020))\n\n      date_firstSeenDay           date_scraping date_sitePublicationDay \n                      0                       0                       0 \n              job_title           job_ROME_code       job_qualification \n                      0                       0                  305296 \n           contractType    contractDuration_min    contractDuration_max \n                      0                  328334                  328334 \ncontractDuration_period  contractDuration_value          workTime_hours \n                      0                  328383                       0 \n      workTime_category          workTime_value          location_label \n                      0                  332206                       0 \n       location_zipcode    location_departement              salary_min \n                  68798                       0                  319455 \n             salary_max           salary_period            salary_value \n                 352552                       0                  319923 \n     salary_hourly_mean       salary_hourly_min       salary_hourly_max \n                 319923                  319923                  352834 \n         entreprise_nom entrepriseSecteur_NAF88 entrepriseSecteur_NAF21 \n                      0                  285597                       0 \n  teleworking_mentioned          experience_min          experience_max \n                      0                     316                  381324 \n        education_level \n                      0 \n\n# Pour les avoir en proportion par rapport au nombre total d'observations\n# et arrondies à 2 chiffres après la virgule :\nround(colMeans(is.na(OffresPE_2020)*100), 2)\n\n      date_firstSeenDay           date_scraping date_sitePublicationDay \n                   0.00                    0.00                    0.00 \n              job_title           job_ROME_code       job_qualification \n                   0.00                    0.00                   72.60 \n           contractType    contractDuration_min    contractDuration_max \n                   0.00                   78.08                   78.08 \ncontractDuration_period  contractDuration_value          workTime_hours \n                   0.00                   78.09                    0.00 \n      workTime_category          workTime_value          location_label \n                   0.00                   79.00                    0.00 \n       location_zipcode    location_departement              salary_min \n                  16.36                    0.00                   75.97 \n             salary_max           salary_period            salary_value \n                  83.84                    0.00                   76.08 \n     salary_hourly_mean       salary_hourly_min       salary_hourly_max \n                  76.08                   76.08                   83.90 \n         entreprise_nom entrepriseSecteur_NAF88 entrepriseSecteur_NAF21 \n                   0.00                   67.91                    0.00 \n  teleworking_mentioned          experience_min          experience_max \n                   0.00                    0.08                   90.68 \n        education_level \n                   0.00 \n\n# Ou en langage tidyverse sur les seules variables numériques :\nOffresPE_2020 %&gt;% \n  summarise(across(.cols = where(is.numeric), .fns = ~ sum(is.na(.)))) %&gt;% \n  gt()\n\n\n\n\n\n\n\njob_qualification\ncontractDuration_min\ncontractDuration_max\ncontractDuration_value\nworkTime_value\nlocation_zipcode\nsalary_min\nsalary_max\nsalary_value\nsalary_hourly_mean\nsalary_hourly_min\nsalary_hourly_max\nentrepriseSecteur_NAF88\nexperience_min\nexperience_max\n\n\n\n\n305296\n328334\n328334\n328383\n332206\n68798\n319455\n352552\n319923\n319923\n319923\n352834\n285597\n316\n381324\n\n\n\n\n\n\n\nOn remarque que sur 31 variables, 14 ont des valeurs manquantes NA. Pour certaines d’entre elles, il y a beaucoup de valeurs manquantes (job_qualification, contratDuration_min, contratDuration_max, contractDuration_value, workTime_value, salary_min, salary_max, salary_value, salary_hourly_mean, salary_hourly_min, salary_hourly_max, entrepriseSecteur_NAF88, experience_max), et pour d’autres un peu moins (location_zipcode, experience_min). En proportion, on se rend compte que pour les premières variables citées, les valeurs manquantes sont présentes pour plus des 3/4 des observations, cela posera forcément des problèmes pour l’analyse !\nPour en faire une analyse plus poussée, différents packages existent pour détecter et visualiser ces données manquantes. L’un d’entre eux est le package naniar : quelques fonctions permettent d’abord de décrire la base selon ses valeurs manquantes. Cela donne un aperçu global et rapide, mais cela n’est vraiment pas suffisant pour comprendre l’origine et les enjeux (possibles problèmes) de ces valeurs manquantes.\n\nlibrary(naniar)# Ci-dessous : nombre de cellules du tableau ou de n_ij d'une matrice \n# qui correspondent à des valeurs manquantes :\nn_miss(OffresPE_2020) \n\n[1] 4343198\n\n# Pour les avoir en proportion du nombre total de cellules du tableau\n# et non des seules lignes comme précédemment, \n# le résultat est déjà en pourcentage, sinon utiliser `prop_miss(RP)`)\npct_miss(OffresPE_2020) \n\n[1] 33.31641\n\n# Ci-dessous : nombre de cellules du tableau ou de n_ij d'une matrice \n# qui correspondent à des valeurs renseignées :\nn_complete(OffresPE_2020) \n\n[1] 8693015\n\n#en proportion\npct_complete(OffresPE_2020) \n\n[1] 66.68359\n\n\nOn peut ensuite visualiser le nombre de valeurs manquantes par variable, avec la fonction gg_miss_var() du même package. On peut également demander dans gg_miss_var() à ce que les valeurs soient en pourcentage, avec l’argument show_pct=TRUE.\n\n# 1er type de visualisation des valeurs manquantes\nOffresPE_2020 %&gt;% gg_miss_var(show_pct=FALSE)\n\n\n\n\n\n\n\n\nLe problème est que pour la variable dont on avait vu qu’elle avait des valeurs vides - contractDuration_period -, ce graphique donne l’impression qu’elle n’a pas de valeurs manquantes. Cela est probablement dû au moment de l’importation des fichiers journaliers de l’ensemble de l’année 2020 et pour les variables caractères, les cellules vides ne sont pas automatiquement remplacées par des “NA” (sauf à mettre l’argument na.strings = c(\"\", \"NA\") dans une fonction read.csv()). Il faut donc pour les variables de type “character” remplacer les celulles vides par des NA, on utilise pour cela la fonction na_if() qui va remplacer pour l’ensemble des variables les valeurs vides \"\" par des Na.\n\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;% \n  mutate(across(.cols = where(is.character), .fns = ~ na_if(., \"\"))) \n\nOffresPE_2020 %&gt;% gg_miss_var(show_pct=FALSE)\n\n\n\n\n\n\n\n\nOn remarque qu’il y a davantage de variables avec des valeurs manquantes.\nOn peut aussi réaliser des graphiques montrant le nombre de valeurs manquantes pour l’ensemble des variables numériques de la base, en fonction d’une autre variable (y compris de nature ‘factor’), avec l’argument fct= dans gg_miss_fct(). Cela est intéressant pour voir si certaines valeurs manquantes des variables sont liées à des valeurs observées d’autres variables, qu’elles soient quantitatives ou qualitatives (et dans ce cas, est-ce que les valeurs manquantes se retrouvent davantage dans certaines modalités plus que d’autres ?). Par exemple, ici, selon le contrat de travail en rassemblant quelques modalités avant :\n\n# on filtre sur les variables numériques car on ne veut pas que la sortie nous affiche \n# toutes les variables.\nOffresPE_2020 %&gt;% select(where(is.numeric), contractType) %&gt;%\n  mutate(contractType=as.factor(case_when(contractType==\"MIS\" ~ \"Intérim\",\n                                          contractType %in% c(\"CDS\",\"SAI\",\"TTI\", \"DDI\") ~ \"Autres CDD\",\n                                          contractType %in% c(\"CCE\", \"REP\", \"DIN\") ~ \"Autres\",\n                                          TRUE ~ contractType))) %&gt;% \n  gg_miss_fct(fct = contractType)\n\n\n\n\n\n\n\n\nOn voit que les valeurs manquantes sont très nombreuses pour certaines modalités de la variable de contrat comme “Franchise” et “Indépendant”. Cela varie ensuite selon les variables, par exemple pour la modalité “CDD” il n’y a aucune valeur manquante pour les variables de durée des contrats mais davantage pour celles sur les salaires. On voit bien que cela peut être logique : on doit donner la durée du contrat pour un CDD mais pas pour un CDI ni un indépendant… Les valeurs manquantes peuvent donc avoir un sens. Ainsi, les valeurs manquantes ne se distribuent pas de manière uniforme selon la variable de contrat de travail, parfois avec une raison, parfois non.\nEnsuite, la fonction gg_miss_upset() de ce même package naniar permet de visualiser des dépendances entre, cette fois, les valeurs manquantes des variables :\n\nOffresPE_2020 %&gt;% select(where(is.numeric)) %&gt;% gg_miss_upset()\n\nWarning: `aes_string()` was deprecated in ggplot2 3.0.0.\nℹ Please use tidy evaluation idioms with `aes()`.\nℹ See also `vignette(\"ggplot2-in-packages\")` for more information.\nℹ The deprecated feature was likely used in the UpSetR package.\n  Please report the issue to the authors.\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\nℹ The deprecated feature was likely used in the UpSetR package.\n  Please report the issue to the authors.\n\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\nℹ Please use the `linewidth` argument instead.\nℹ The deprecated feature was likely used in the UpSetR package.\n  Please report the issue to the authors.\n\n\n\n\n\n\n\n\n\nCela nous montre qu’il y a beaucoup d’observations où on a des valeurs manquantes pour 5 variables indiquées, qu’ensuite le cas le plus probable c’est des valeurs manquantes pour 4 de ces 5 variables, etc.\nEnfin, il est possible d’appliquer la fonction geom_miss_point() à une fonction ggplot, dans ce cas les valeurs manquantes de la ou des variables sont remplacées par des valeurs 10% plus basses que la valeur minimum observée des variables, et cela afin de les visualiser.\nIl existe bien sûr bien d’autres packages, comme funModeling, Amelia et sa fonction missmap(), ou encore visdat et sa fonction vis_miss(). Enfin, d’autres packages comme VIM ou MICE permettent, non seulement de visualiser ces valeurs manquantes, mais également de leur appliquer des techniques pour les “gérer”, c’est ce que l’on va voir maintenant en résumé.\n\n\n3.2.2 Gérer les valeurs manquantes\nIl est bien de connaître le nombre et la proportion de valeurs manquantes dans nos données, comment ces dernières se répartissent entre elles, etc., mais il faut aussi comprendre quel impact elles peuvent avoir sur des analyses statistiques, de régressions ou autres algorithmes.\nDans une base de données tirée d’une enquête, les valeurs manquantes peuvent provenir d’une non-réponse de la part de l’enquêté (que ce soit un individu ou une entreprise), cette non-réponse pouvant être “totale” (on a aucune donnée pour cet enquêté alors qu’il fait partie de l’échantillon) ou “partielle” (on a une partie des réponses mais pas à toutes les questions et donc des variables parfois avec des valeurs manquantes) ; ou bien encore elles peuvent être dues à une mauvaise saisie de l’information par l’enquêteur. La pondération, si elle est présente dans une enquête, peut permettre de corriger cette non-réponse totale, voire partielle.\nLes conséquences des valeurs manquantes dans une base de données dépendent de plusieurs choses : on doit d’abord se demander si l’information perdue aurait été pertinente et/ou aurait apporté un élément particulier/supplémentaire. Ensuite, la perte éventuelle d’information est-elle importante, en nombre/en proportion. Et enfin (et surtout), peut-elle créer un biais lors de l’estimation et de la précision du phénomène que l’on souhaite observer, décrire, analyser, etc. Selon l’importance de ces conséquences, il faut traiter ces valeurs manquantes, c’est-à-dire utiliser une procédure la plus adaptée possible selon le potentiel biais repéré.\nTraditionnellement dans la littérature, on distingue 3 types de valeurs manquantes :\n\nvaleur manquante entièrement due au hasard (‘MCAR’ pour Missing completely at random) : il n’y a pas de lien entre la valeur manquante pour une variable donnée et les autres variables, dit autrement la probabilité pour une variable qu’elle ait une valeur manquante est constante dans les données, elle ne diffère pas selon d’autres caractéristiques des individus ;\nvaleur manquante due au hasard (‘MAR’ pour Missing at random) : il y a un lien entre la valeur manquante pour une variable donnée et les valeurs observées d’autres variables, c’est-à-dire que la probabilité pour une variable qu’elle ait une valeur manquante dépend d’autres variables (de leurs valeurs observées), elle ne sera donc pas la même selon les individus, c’est ce qu’on essayait de regarder lorsqu’on a utilisé plus haut la fonction gg_miss_fct(fct=) ;\nvaleur ne manquant pas au hasard (‘NMAR’ pour Non missing at random) : il y a un lien entre la valeur manquante pour une variable et les valeurs manquantes/non observées d’autres variables. Ce sont celles qui risquent d’entraîner des biais importants si on ne les traite pas, c’est ce qu’on essayait de regarder plus haut également avec la fonction gg_miss_upset() cette fois.\n\nComment alors les gérer ? En pratique, il est d’usage lorsque la proportion de valeurs manquantes ne dépasse pas 5% des données de ne rien faire de particulier ou simplement de les supprimer (vous pouvez pour la savoir utiliser les premières fonctions du package naniar présentées précédemment). Sinon, on essaye d’appliquer plusieurs méthodes, simples ou plus complexes.\nDans le cas de valeurs manquantes entièrement dues au hasard (MCAR) et/ou d’une faible proportion des valeurs manquantes dans le total de la table de données, on peut décider de supprimer toutes les lignes qui contiennent au moins une valeur manquante, afin d’avoir une table de données complètes, on peut utiliser la fonction na.omit() ou complete.cases() ; attention à ne pas remplacer votre table de données initiale en réalisant cette procédure. On ne va pas s’essayer à le faire ici car on a vu au tout début de cette section que pour certaines variables cela concernait beaucoup d’observations (comme le salaire ou la durée du contrat pour les CDI), la conséquence c’est qu’ici on va supprimer toutes les lignes car une ligne a forcément une valeur manquante dans une des variables. Le code serait celui-ci :\n\nOffresPE_2020_sansNA &lt;- na.omit(OffresPE_2020)\n# OU : \n# OffresPE_2020_sansNA &lt;- OffresPE_2020[complete.cases(OffresPE_2020), ]\n\nDes techniques d’imputation simple peuvent également être utilisées. On peut par exemple remplacer les valeurs manquantes d’une variable quantitative par sa moyenne ou sa médiane, pour cela on peut utiliser la fonction replace_na() du package tidyr, ou impute() du package Hmisc, ou encore na.aggregate() du package zoo On donne ainsi une valeur “artificielle” pour remplacer la valeur manquante. Dans le cas de variables qualitatives, on peut, de même, imputer la modalité dominante (avec la fonction mode() du package Hmisc ; ou avec l’argument mode= du package zoo). Par exemple, voici les codes pour remplacer les valeurs manquantes de la variable ‘salary_value’ par sa médiane (la base n’étant pas propre il vaut mieux utiliser la médiane que la moyenne) :\n\nOffresPE_2020 %&gt;% \n  mutate(salary_value_bis = replace_na(salary_value, \n                                       median(salary_value, na.rm=TRUE))) %&gt;% \n  select(salary_value, salary_value_bis) %&gt;% \n  filter(is.na(salary_value)) %&gt;% \n  head(5)\n\n  salary_value salary_value_bis\n1           NA            14.83\n2           NA            14.83\n3           NA            14.83\n4           NA            14.83\n5           NA            14.83\n\n# library(Hmisc)\n# OffresPE_2020$salary_value_bis &lt;- with(OffresPE_2020, impute(salary_value, median))\n# \n# library(zoo)\n# OffresPE_2020$salary_value_bis &lt;- na.aggregate(OffresPE_2020$ salary_value, \n#                                                FUN = median)\n\nOn peut néanmoins réaliser ce type d’imputation simple de manière un petit peu plus subtile. Par exemple, si la moyenne de la variable diffère sensiblement selon une autre variable (catégorielle), dans ce cas, on va plutôt remplacer les valeurs manquantes de la variable selon la moyenne associée à chaque modalité de cette autre variable en ajoutant un group_by() avant la fonction mutate() si on utilise la fonction replace_na() comme dans l’exemple précédent.\nSi on ne veut pas supprimer ces lignes d’observations et perdre ainsi d’autres informations (celles des variables pour lesquelles la valeur était renseignée pour cette même observation), on peut simplement créer une variable indicatrice de valeur manquante, remplacer les NA par ‘999’ pour des variables quantitatives, ou par une modalité ‘Manquant’ ou ‘Missing’ pour des variables qualitatives.\nPlusieurs autres méthodes existent également dans le cas de valeurs manquantes dues au hasard (MAR), en voici la liste pour information et sans prétention d’exhaustivité : - analyse pondérée pour des valeurs MAR qui consiste à calculer la probabilité qu’une observation soit complète et ensuite à affecter à chacune des observations complètes, un poids inversement proportionnel à cette probabilité ; - imputation de la dernière observation pour des données temporelles ; - imputation “hot-deck” qui consiste à remplacer la valeur manquante par une valeur observée chez un autre individu ayant les mêmes caractéristiques, ou “cold-deck” (même démarche que précédement, sauf que la valeur imputée vient d’une autre source) ; - imputation par le “plus proche voisin” en utilisant une fonction de distance basée sur plusieurs autres variables/caractéristiques de l’individu ; - imputation par un modèle de régression où l’on va remplacer la valeur manquante par une valeur prédite obtenue par régression sur données complètes de la variable comportant des valeurs manquantes.\nIl y a aussi des techniques plus complextes d’imputation multiple qui consiste à créer plusieurs valeurs possibles pour une valeur manquante d’une variable, cela peut être adaptée là aussi lorsque les valeurs manquantes sont dues au hasard (MAR).\nVous trouverez de multiples ressources sur internet dans des ouvrages libres d’accès, ou vous pouvez aller voir un des chapitres de l’ouvrage principal support du cours (Husson, 2018), avec des exemples d’utilisation.\n\n\n3.2.3 Détecter et “visualiser” les valeurs aberrantes\nOn va continuer avec cette base de données en s’intéressant maintenant aux valeurs aberrantes.\nOn peut d’abord étudier la distribution de ces variables : la fonction get_summary_stats() du package rstatix permet de donner les statistiques de distribution des variables. On propose d’afficher ici les variables de salaire, d’expérience minimum, de durée des contrat et de temps de travail, pour les seuls CDD et CDI pour que cela soit plus pertinent.\n\nlibrary(rstatix)\n# Au total : 65 449 CDD ; 315 063 CDI\n\n# 'contractDuration_value' : exprimée en jours\n# 'experience_min' : nombre minimum d’années d’expérience nécessaire pour le\n#   poste (0 s’il est précisé que les personnes sans expérience sont acceptées).\n# 'salary_hourly_mean' : salaire horaire, moyen si min et max proposé, et recalculé\n#   selon la plage temporelle dans laquelle le salaire est exprimé.\n# 'workTime_value' : temps de travail exprimé en heures\n\nOffresPE_2020 %&gt;% filter(contractType %in% c(\"CDD\", \"CDI\")) %&gt;% \n  group_by(contractType) %&gt;% \n  get_summary_stats(salary_value, salary_min, salary_hourly_mean,\n                    experience_min, contractDuration_value, workTime_value,\n                    show=c(\"n\",\"mean\", \"median\", \"min\", \"max\",\"q1\", \"q3\")) %&gt;%\n  gt()\n\n\n\n\n\n\n\ncontractType\nvariable\nn\nmean\nmedian\nmin\nmax\nq1\nq3\n\n\n\n\nCDD\nsalary_value\n19920\n14.798\n12.43\n0.31\n1540\n10.44\n16.48\n\n\nCDD\nsalary_min\n20229\n6399.724\n1600.00\n3.00\n288000\n20.00\n2130.00\n\n\nCDD\nsalary_hourly_mean\n19920\n14.412\n12.31\n0.31\n1540\n10.35\n16.18\n\n\nCDD\nexperience_min\n65416\n0.561\n0.00\n0.00\n20\n0.00\n1.00\n\n\nCDD\ncontractDuration_value\n65283\n163.510\n130.00\n1.00\n20656\n108.00\n217.00\n\n\nCDD\nworkTime_value\n22702\n26.393\n35.00\n1.00\n50\n14.00\n35.00\n\n\nCDI\nsalary_value\n70438\n21.059\n16.15\n0.16\n40200\n11.87\n23.03\n\n\nCDI\nsalary_min\n70582\n17120.800\n3000.00\n3.00\n350000\n1700.00\n32000.00\n\n\nCDI\nsalary_hourly_mean\n70438\n21.189\n16.48\n0.16\n40200\n12.19\n23.34\n\n\nCDI\nexperience_min\n314781\n1.268\n1.00\n0.00\n35\n0.00\n2.00\n\n\nCDI\nworkTime_value\n57335\n32.703\n35.00\n1.00\n56\n35.00\n35.00\n\n\n\n\n\n\n\nCela nous permet de comprendre qu’il y a probablement encore quelques filtres à effectuer pour avoir une base propre et cohérente, non seulement sur les valeurs maximum - on va y venir - mais aussi sur les valeurs minimum. Peut-on ainsi avoir un salaire brut horaire proposé de 0,16€ (minimum) ou de 40200€ (maximum) dans les offres d’emploi en CDI ? De plus, comme on a vu qu’il y avait beaucoup de valeurs manquantes sur les variables de salaire ou de temps de travail, il faudra indiquer que ces valeurs ne sont pas nécessairement représentatives de l’ensemble des offres de Pôle emploi.\nOn peut également faire quelques graphiques sur ces variables pour mieux visualiser ces valeurs aberrantes, par exemple un histogramme, ou une “boîte à moustache” (seule ou en relation avec une autre variable) :\n\nOffresPE_2020 %&gt;%  \n  ggplot() + aes(x = salary_hourly_mean) + geom_histogram(bins=50)\n\nWarning: Removed 319923 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\nOffresPE_2020 %&gt;% \n  ggplot() + aes(y = salary_hourly_mean) +  geom_boxplot() +\n  coord_flip()\n\nWarning: Removed 319923 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\nOn voit bien des points aberrants qui “écrasent” les représentations graphiques, que ce soit avec l’histogramme ou la boîte à moustâche, de telle sorte qu’on ne voit même pas la distribution, en particulier dans le Boxplot la “boîte” en elle-même.\nPour rappel, dans un boxplot, par défaut un point est affiché comme aberrant s’il est en dehors de l’intervalle suivant : \\(I=[Q_{1}−1.5×IQR ; Q_{3}+1.5×IQR]\\), IQR étant l’intervalle interquartile donc la différence entre Q1 et Q3.\nMais s’agit-il de “vraies” valeurs aberrantes ? Combien d’observations concernent-elles ? La fonction boxplot.stats() permet de récupérer les valeurs des observations indiquées comme aberrantes, comme cela on peut créer ensuite une variable indiquant si oui ou non l’observation a une valeur “aberrante”. Faisons-cela pour la variable de salaire horaire (brut) moyen.\n\n# On récupère les valeurs de la partie 'out' des sorties de la fonction\n# 'boxplot.stats', qui correspondent aux valeurs de tout point de données\n# qui se situe au-delà des extrêmes de la boxplot\nval_outliers &lt;- boxplot.stats(OffresPE_2020$salary_hourly_mean)$out \n\n# On crée une variable dans notre table d'\"identification\" de ces outliers avec\n# comme modalité \"vraie\" si l'observation a une valeur \"outliers\", sinon \"Faux\"\n# et en créant une modalité pour les valeurs manquantes\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;% \n  mutate(salary_outliers = \n           case_when(is.na(salary_hourly_mean) ~ \"NA\",\n                     salary_hourly_mean %in% c(val_outliers) ~ \"Vrai\",\n                     TRUE ~ \"Faux\"))\n\n# Puis on regarde la répartition avec la fonction `tabyl()` du package `janitor()` \nlibrary(janitor)\nOffresPE_2020 %&gt;%  tabyl(salary_outliers) %&gt;% \n  adorn_totals(\"row\") %&gt;% adorn_pct_formatting() %&gt;% \n  gt()\n\n\n\n\n\n\n\nsalary_outliers\nn\npercent\n\n\n\n\nFaux\n97233\n23.1%\n\n\nNA\n319923\n76.1%\n\n\nVrai\n3367\n0.8%\n\n\nTotal\n420523\n100.0%\n\n\n\n\n\n\nOffresPE_2020 %&gt;% filter(salary_outliers !=\"NA\") %&gt;% \n  tabyl(salary_outliers) %&gt;% \n  adorn_totals(\"row\") %&gt;% adorn_pct_formatting() %&gt;% \n  gt()\n\n\n\n\n\n\n\nsalary_outliers\nn\npercent\n\n\n\n\nFaux\n97233\n96.7%\n\n\nVrai\n3367\n3.3%\n\n\nTotal\n100600\n100.0%\n\n\n\n\n\n\n\nOn y lit que pour cette variable lorsqu’elle est renseignée, il y aurait près de 3,3% de valeurs aberrantes telles qu’indiquées par le boxplot, ce qui correspondant à 3 367 observations, c’est beaucoup ! On peut regarder plus précisément à quelles observations elles correspondent, en sélectionnant avec la variable créée et en triant par ordre croissant ou décroissant.\n\nOffresPE_2020 %&gt;% filter(salary_outliers=='Vrai') %&gt;% \n  select(salary_hourly_mean, contractType)  %&gt;% \n  arrange(salary_hourly_mean) %&gt;% head(5) %&gt;% \n  gt()\n\n\n\n\n\n\n\nsalary_hourly_mean\ncontractType\n\n\n\n\n35.60\nCDI\n\n\n35.60\nCDD\n\n\n35.71\nCDI\n\n\n35.72\nCDI\n\n\n35.79\nCDI\n\n\n\n\n\n\nOffresPE_2020 %&gt;% filter(salary_outliers=='Vrai') %&gt;% \n  select(salary_hourly_mean, contractType)  %&gt;% \n  arrange(desc(salary_hourly_mean)) %&gt;% head(5) %&gt;% \n  gt()\n\n\n\n\n\n\n\nsalary_hourly_mean\ncontractType\n\n\n\n\n40200\nCDI\n\n\n35000\nCDI\n\n\n26000\nMIS\n\n\n22000\nMIS\n\n\n20015\nCDI\n\n\n\n\n\n\n\nOn voit donc qu’il y a des valeurs considérées comme aberrantes en haut de la distribution, à partir d’un salaire brut horaire de 35,60€ (tri par odre croissant), les plus hauts salaires brut horaires étant de 40200€ ou 35000 (tri par ordre décroissant). Attention, un salaire brut horaire de 35,60€ correspond pour un temps plein (35H/semaine) à un salaire brut mensuel d’environ 4984€, est-ce vraiment une valeur aberrante ?! Pour être plus précis, on peut calculer les valeurs seuils bas et haut puisqu’on connaît la formule. Le seuil bas sera : -2.79 et le seuil haut : 35.53. Comme déjà dit, le seuil haut est vraisemblables en réalité, en revanche avoir un salaire brut horaire négatif ou proche de 0 n’est pas possible ! Il est donc important de comprendre ces valeurs aberrantes, cela peut parfois correspondre à des observations intéressantes à conserver, il ne s’agit pas juste de les identifier pour les exclure directement ensuite des analyses.\nIl existe d’autres méthodes (méthode basée sur les percentiles ; méthode de Hampel), et d’autres tests : par exemple, le package outliers vous permet de tester si une valeur (max ou min) est bien une valeur aberrante avec la fonction grubbs.test() (attention bis : à utiliser avec grande précaution et beaucoup de parcimonie), ou avec le package EnvStats et la fonction rosnerTest() pour détecter plusieurs “outliers” à la fois.\nPour gérer ces variables aberrantes, on peut les supprimer bien sûr si l’on est sûr que la valeur de la variable n’est pas “normale”, par exemple comme ici quand la variable de salaire est inférieure ou égale à 0 (ou même inférieure au SMIC), oui dans ce cas ce sont des mauvais outliers (et d’ailleurs parfois ils peuvent même ne pas être identifiés comme tel statistiquement) et on peut les supprimer ; de même pour des variables de résultats économiques, on va souvent élaguer la distribution en retirant les 1% (par exemple) du bas et du haut de la distribution pour supprimer des potentiels outliers. On peut tenter cette méthode ici en filtrant les données avant de calculer la distribution de la variable.\nSinon, on les isole en créant une variable dichotomique “0/1” ou “Faux/Vrai” ; ou on crée une variable qualitative avec plusieurs catégories (cf. sous-section suivante).\nDans les graphiques, en particulier les boîtes à moustache, on peut les supprimer visuellement avec l’option outlier.shape = NA et mettre ensuite une échelle plus réduite (avec ylim=c( , )) pour que le graphique soit plus lisible, mais il faut alors bien préciser dans la légende que certaines valeurs ne sont pas visibles sur le graphique car retirées ; attention à ne pas les supprimer de la base sur laquelle est réalisée la boxplot car sinon cela va modifier les indicateurs (en particulier de moyenne mais pas seulement). Dans un histogramme, on peut de même jouer sur l’échelle.\n\nOffresPE_2020 %&gt;% \n  ggplot() + aes(y = salary_hourly_mean) + \n  geom_boxplot(outlier.shape = NA) + \n  coord_flip(ylim = c(quantile(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean), ]$salary_hourly_mean, 0.01),\n                      quantile(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean), ]$salary_hourly_mean, 0.99))) +\n  labs(title = \"Distribution des salaires horaires brut en euros des offres d'emploi reçus sur \\nle site de Pôle emploi en 2020\", \n       y=\"\", x=\"\", \n       caption=\"Rq : les valeurs en-dessous du 1% de la distribution et celles au-dessus du 99% de la distribution ne sont pas \\naffichées sur le graphique ; de même pour les valeurs considérées comme aberrantes selon la statistique du boxplot.\") +\n  theme(plot.caption = element_text(hjust=0))\n\nWarning: Removed 319923 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\nOffresPE_2020 %&gt;%\n  ggplot() + aes(salary_hourly_mean) + \n  geom_histogram(bins=50000) + \n  coord_cartesian(xlim=c(quantile(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean), ]$salary_hourly_mean, 0.01),\n                         quantile(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean), ]$salary_hourly_mean, 0.99))) +\n  labs(title = \"Distribution des salaires horaires brut en euros des offres d'emploi reçus sur \\nle site de Pôle emploi en 2020\", \n       y=\"\", x=\"Salaire horaire brut\",\n       caption=\"Rq : les valeurs en-dessous du 1% de la distribution et celles au-dessus du 99% de la distribution ne sont pas \\naffichées sur le graphique.\") +\n  theme(plot.caption = element_text(hjust=0))\n\nWarning: Removed 319923 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nC’est mieux mais on voit qu’il y a probablement encore un problème pour les valeurs faibles du salaire qu’il faudrait “nettoyer”. On peut refaire le graphique en élaguant davantage en bas de la distribution et en haut à partir de valeurs de salaire connus par exemple :\n\n# On peut filtrer directement avec des valeurs de salaire horaire brut \"connu\" \n# (comme la valeur du SMIC ou la valeur du 9ème décile, cf. site de l'Insee)\nOffresPE_2020 %&gt;% filter(salary_hourly_mean&gt;=10 & salary_hourly_mean&lt;90) %&gt;% \n  ggplot() + aes(y = salary_hourly_mean) + \n  geom_boxplot() + \n  coord_flip() +\n  labs(title = \"Distribution des salaires horaires brut en euros des offres d'emploi reçus sur \\nle site de Pôle emploi en 2020\",\n       y=\"\", x=\"\", \n       caption=\"Rq : les valeurs en-dessous du SMIC horaire brut et celles au-dessus du 9ème décile de la distribution des salaires \\nprivés en France ne sont pas affichées sur le graphique.\") +\n  theme(plot.caption = element_text(hjust=0)) \n\n\n\n\n\n\n\nOffresPE_2020 %&gt;% filter(salary_hourly_mean&gt;=10 & salary_hourly_mean&lt;90) %&gt;% \n  ggplot() + aes(salary_hourly_mean) + \n  geom_histogram(bins=100) + \n  labs(title = \"Distribution des salaires horaires brut en euros des offres d'emploi reçus sur \\nle site de Pôle emploi en 2020\",\n       y=\"\", x=\"Salaire horaire brut\",\n       caption=\"Rq : les valeurs en-dessous du SMIC horaire brut et celles au-dessus du 9ème décile de la distribution des salaires \\nprivés en France ne sont pas affichées sur le graphique.\") +\n  theme(plot.caption = element_text(hjust=0))\n\n\n\n\n\n\n\n\n\n\n3.2.4 Découper une variable quantitative en classes\nOn peut enfin découper en classes une variable quantitative et en faire donc une variable qualitative. On utilise pour cela la fonction cut() du langage de base de R. On peut par exemple découper la variable selon les principaux indicateurs de la distribution.\n\n# OffresPE_2020 %&gt;% get_summary_stats(salary_hourly_mean)\nOffresPE_2020$salary_cat &lt;- cut(OffresPE_2020$salary_hourly_mean,\n                                breaks = c(0,\n                                           10,   \n                                           quantile(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean),]$salary_hourly_mean,0.25),  \n                                           mean(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean),]$salary_hourly_mean),\n                                           90,\n                                           max(OffresPE_2020[!is.na(OffresPE_2020$salary_hourly_mean),]$salary_hourly_mean)),\n                                labels=c(\"Entre 0 et moins que le SMIC (10€)\",\n                                         \"Entre le SMIC et le Q1(11,58€)\",\n                                         \"Entre le Q1 et la moyenne (20,07€)\",\n                                         \"Entre la moyenne et le D9 observée en France\",\n                                         \"Entre le D9 et le maximum (40200€)\"))\n\nOffresPE_2020 %&gt;% tabyl(salary_cat) %&gt;% adorn_totals(\"row\") %&gt;% \n  adorn_pct_formatting() %&gt;% gt()\n\n\n\n\n\n\n\nsalary_cat\nn\npercent\nvalid_percent\n\n\n\n\nEntre 0 et moins que le SMIC (10€)\n3489\n0.8%\n3.5%\n\n\nEntre le SMIC et le Q1(11,58€)\n21668\n5.2%\n21.5%\n\n\nEntre le Q1 et la moyenne (20,07€)\n47138\n11.2%\n46.9%\n\n\nEntre la moyenne et le D9 observée en France\n27930\n6.6%\n27.8%\n\n\nEntre le D9 et le maximum (40200€)\n375\n0.1%\n0.4%\n\n\nNA\n319923\n76.1%\n-\n\n\nTotal\n420523\n100.0%\n100.0%\n\n\n\n\n\n\n\nOn a une classe majoritaire (du Q1 à la moyenne), mais cela nous permet de distinguer 2 classes pour lesquelles le montant du salaire horaire brut est soit plutôt faible mais au-dessus du SMIC, soit plutôt élevé mais en-dessous de la valeur D9 observée en France.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulation des variables</span>"
    ]
  },
  {
    "objectID": "04-Récapitulatif.html",
    "href": "04-Récapitulatif.html",
    "title": "4  Récapitulatif séance 1 - Data Wrangling",
    "section": "",
    "text": "4.1 Ce qu’on a appris\nCette séance sur la préparation et nettoyage d’une base de données - phase appelée aussi Data Wrangling - nous a permis d’apprendre à :\nL’usage pour cette phase du langage dplyr ou plus généralement du tidyverse est particulièrement conseillée, cela permet d’“enchaîner” des fonctions en une seule instruction.",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Récapitulatif séance 1 - Data Wrangling</span>"
    ]
  },
  {
    "objectID": "04-Récapitulatif.html#ce-quon-a-appris",
    "href": "04-Récapitulatif.html#ce-quon-a-appris",
    "title": "4  Récapitulatif séance 1 - Data Wrangling",
    "section": "",
    "text": "charger des bases de données, y compris dans le cas d’un fichier lourd avec la fonction fread() du package data.table ;\nrepérer les informations intéressantes contenues dans cette base, notamment en allant voir le fichier “annexe”, celui des métadonneés (ou dictionnaire des codes) ; mais ce type de fichier n’est pas toujours disponible, si vous avez des données d’une entreprise, peut-être que l’information décrivant cette base est plus informelle, ou même si vous “aspirez” des données via le web vous n’aurez alors pas du tout d’information décrivant la base… :\nmanipuler la base de données : en identifiant d’abord le format des données, en sélectionnant un champ différent (moins de lignes/d’observations), et/ou des variables spécifiques (moins de colonnes/d’informations), avec les fonctions filter(), select(), subset(), pivot_wider(), pivot_longer(), unique(), arrange(), etc.;\nmanipuler des variables : en identifiant le format des variables, en les mettant dans le bon format, en (re)travaillant les modalités d’une variable qualitative (avec notamment les fonctions mutate(), case_when(), as.factor(), ou encore celles du package factors), en détectant/visualisant/gérant les valeurs manquantes d’une variable quantitative avec entre autres le package naniar, en détectant/visualiant/gérant les valeurs aberrantes d’une variable quantitative à partir en particulier des statistiques de la “boîte à moustaches” (fonction geom_boxplot() à utiliser avec ggplot(), fonction boxplot.stats()), et enfin, en transformant une variable quantitative en variable qualitative (avec la fonction cut()).",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Récapitulatif séance 1 - Data Wrangling</span>"
    ]
  },
  {
    "objectID": "04-Récapitulatif.html#enregistrement-des-tables",
    "href": "04-Récapitulatif.html#enregistrement-des-tables",
    "title": "4  Récapitulatif séance 1 - Data Wrangling",
    "section": "4.2 Enregistrement des tables",
    "text": "4.2 Enregistrement des tables\nEt voilà, on a bien “trituré” ces deux bases de données, maintenant on peut les enregistrer dans notre projet pour pouvoir les réutiliser lors de la prochaine séance.\n\n# On enregistre les tables de données pour les utiliser ultérieurement\nsaveRDS(object = RP_final,  file = \"data/RP_final.Rdata\")\nsaveRDS(object = meta,  file = \"data/meta.Rdata\")\nsaveRDS(object = OffresPE_2020, file = \"data/OffresPE_2020.Rdata\")",
    "crumbs": [
      "Séance 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Récapitulatif séance 1 - Data Wrangling</span>"
    ]
  },
  {
    "objectID": "05-Questions-fouille-donnees.html",
    "href": "05-Questions-fouille-donnees.html",
    "title": "5  Quelles questions intéressantes pour une “fouille de données” sur la base des RP ?",
    "section": "",
    "text": "5.1 Caractéristiques de la population résidant à Paris\nQuelles sont les questions intéressantes que l’on peut se poser ? Qu’est-ce qu’on va pouvoir mettre en évidence à partir de ces données ?\nD’abord, on peut caractériser la population de Paris et sa petite couronne selon des variables socio-démographiques (sexe, âge, diplôme, statut conjugal, nombre d’enfants, …) et d’emploi (statut d’activité, PCS, condition d’emploi - contrat, temps de travail -, secteur d’activité, …). Ensuite, on peut décrire les logements de Paris et sa petite couronne, selon le type (appartement, maison, HLM, …), la superficie, le nombre de pièces, le nombre de personnes y habitant, le statut d’occupation (propriétaire, locataire, …), l’ancienneté d’occupation. Enifn, on peut décrire plus précisément les pièces du logement en termes de confort (baignoire / douche, salle climatisée, moyen de chauffage), ainsi que les parties communes de l’immeuble (ascenseur, place de stationnement). Enfin, on pourrait étudier les caractéristiques des occupants de ces logements, et en premier lieu ici ce que l’Insee appelle la “personne de référence du ménage”. Par ailleurs, toutes ces analyses peuvent être réalisées en comparant les différentes communes de Paris et sa petite couronne, ou à un niveau géographique plus fin par quartiers, arrondissements ou encore IRIS.\nPour manipuler cette base et répondre à quelques-unes de ces questions, nous allons nous concentrer sur la commune de Paris, et allons chercher à reproduire des statistiques publiées sur le site de l’Insee. Nous produirons principalement, lors de cette séance, des tableaux de statistiques, l’analyse graphique fera en effet l’objet de la séance suivante car elle nécessite la présentation détaillée de la “grammaire” Ggplot.\nAvant cela, si les tables de données (“RP_final” et “meta”) ne sont plus dans votre environnement local, il faut de nouveau les importer à partir de l’enregistrement précédemment effectué dans le dossier ‘data’ de votre projet. Pour cela, il faut utiliser la fonction readRDS(), comme ci-dessous :\nSur le site de l’Insee, vous pouvez trouver les statistiques générales sur les individus à Paris en 2019 ici et là.\nComme déjà vu lors de la 1ère séance, l’application de la pondération pour avoir des statistiques représentatives de la population peut être utilisée à l’intérieur de la fonction count() avec l’argument wt=. Cela nous donnera le nombre d’individus concernés par la caractéristique étudiée (par défaut, la variable créée s’appelle “n”, on peut la renommer dans une étape ultérieure avec la fonction rename()). Souvent, on souhaite aussi avoir les pourcentages, on peut alors créer une variable rapportant le nombre de chaque catégorie sur le nombre total d’individus, avec la fonction prop.table() utilisée dans la fonction mutate(). Le package janitor peut permettre enfin d’ajouter une ligne totale (ou une colonne totale selon ce qu’on souhaite faire) avec la fonction adorn_totals(), argument “row” pour avoir le total en ligne ou “col” pour l’avoir en colonne. Des fonctions supplémentaires liées au package gt() peuvent ensuite être utilisées pour mettre en forme le tableau : fmt_number(), tab_header() ou encore tab_source_note().\nA partir de ces indications, afficher le tableau suivant à partir d’un code utilisant le langage tidyverse et en une seule procédure (sans créer de table dans votre environnement) :\nAttachement du package : 'janitor'\n\n\nLes objets suivants sont masqués depuis 'package:stats':\n\n    chisq.test, fisher.test\n\n\n\n\n\n\n\n\nPopulation par sexe en 2019\n\n\nSexe\nEffectif\nPourcentage\n\n\n\n\nFemmes\n1 146 436\n52.9\n\n\nHommes\n1 019 195\n47.1\n\n\nTotal\n2 165 631\n100.0\n\n\n\nSource : Insee, RP 2019 ; Champ : Paris.\nIl y a plus de femmes habitant Paris en 2019, environ 53%.\nCherchons maintenant la répartition de la population parisienne par type d’activité : quelle est la proportion d’actifs ayant un emploi par rapport à la part des chômeurs ou encore des retraités ? Attention au champ sur lequel porte ces statistiques (lire le titre du tableau pour cela…).\nPopulation des 15-64 ans par type d'activité en 2019\n\n\nType d'activité\nEffectif\nPourcentage\n\n\n\n\nActifs ayant un emploi\n1 042 588\n69.3\n\n\nChômeurs\n135 014\n9.0\n\n\nÉlèves, étudiants et stagiaires non rémunérés\n192 205\n12.8\n\n\nRetraités ou préretraités\n38 512\n2.6\n\n\nAutres inactifs\n95 944\n6.4\n\n\nTotal\n1 504 263\n100.1\n\n\n\nSource : Insee, RP 2019 ; Champ : Paris.\nEn 2019, la population parisienne comportait plus de 78% d’actifs dont 69% ayant un emploi et 9% au chômage, le taux de chômage à Paris était donc de 11,5% (135014/(1042588+135014))*100). La part des étudiants ou autres élèves était plus élevée que celle des retraités (ou préretaités) : 12,8% contre 2,6%.",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quelles questions intéressantes pour une \"fouille de données\" sur la base des RP ?</span>"
    ]
  },
  {
    "objectID": "05-Questions-fouille-donnees.html#caractéristiques-de-la-population-résidant-à-paris",
    "href": "05-Questions-fouille-donnees.html#caractéristiques-de-la-population-résidant-à-paris",
    "title": "5  Quelles questions intéressantes pour une “fouille de données” sur la base des RP ?",
    "section": "",
    "text": "TipSolution\n\n\n\n\n\n\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(gt)\nRP_final %&gt;% \n  filter(DEPT == \"75\") %&gt;% \n  mutate(SEXE=case_when(SEXE==\"1\" ~ \"Hommes\", SEXE==\"2\" ~ \"Femmes\")) %&gt;% \n  count(SEXE, wt=IPONDI) %&gt;% \n  mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% \n  adorn_totals(\"row\") %&gt;% \n  rename(Effectif=n, 'Sexe'=SEXE) %&gt;% \n  gt() %&gt;% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\") %&gt;% \n  tab_header(title = \"Population par sexe en 2019\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nRP_final %&gt;% \n  filter(DEPT == \"75\" & !AGEREVQ %in% c(\"0\", \"5\", \"10\", \"65\", \"70\", \"75\", \"80\", \"85\", \"90\", \"95\", \n                                        \"100\", \"105\", \"110\", \"115\", \"120\")) %&gt;% \n  mutate(TACT=case_when(TACT == \"11\" ~ \"Actifs ayant un emploi\",\n                             TACT == \"12\" ~ \"Chômeurs\",\n                             TACT == \"22\" ~ \"Élèves, étudiants et stagiaires non rémunérés\",\n                             TACT == \"21\" ~ \"Retraités ou préretraités\",\n                             TRUE ~ \"Autres inactifs\"),\n         TACT=fct_relevel(TACT, c(\"Actifs ayant un emploi\", \"Chômeurs\",\n                                            \"Élèves, étudiants et stagiaires non rémunérés\", \n                                            \"Retraités ou préretraités\", \"Autres inactifs\"))) %&gt;% \n  count(TACT, wt=IPONDI) %&gt;% \n  mutate(Pourcentage=round(prop.table(n)*100,1)) %&gt;% \n  adorn_totals(\"row\") %&gt;% \n  rename(Effectif=n, \"Type d'activité\"=TACT) %&gt;% \n  gt() %&gt;% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population des 15-64 ans par type d'activité en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quelles questions intéressantes pour une \"fouille de données\" sur la base des RP ?</span>"
    ]
  },
  {
    "objectID": "05-Questions-fouille-donnees.html#caractéristiques-de-la-population-active-résidant-à-paris",
    "href": "05-Questions-fouille-donnees.html#caractéristiques-de-la-population-active-résidant-à-paris",
    "title": "5  Quelles questions intéressantes pour une “fouille de données” sur la base des RP ?",
    "section": "5.2 Caractéristiques de la population active résidant à Paris",
    "text": "5.2 Caractéristiques de la population active résidant à Paris\nMaintenant, affichons les deux dernières colonnes (‘2019’ et ‘dont actifs ayant un emploi’) de ce tableau tiré du site de l’Insee, en mettant la ligne “Ensemble” plutôt en fin de tableau (ces 2 usages sont possibles, question de préférence…). Attention encore une fois au champ de ce tableau… Pour cela, on va :\n\nrécupérer les libellés des modalités de la variable CS1 à partir du fichier ‘meta’, en créant 2 vecteurs correspondant aux modalités pour le 1er et aux libellés pour le 2nd, puis en créant une variable ‘CS1_moda’ à partir de ces vecteurs ;\ncréer une 1ère table qu’on appellera ‘col2’ qui comportera la 1ère colonne avec les intitulés des PCS et la colonne ‘2019’, attention, il y a une modalité qui ne nous intéresse pas car non affiché dans le tableau de l’Insee, il faudra supprimer cette ligne (vous pouvez utiliser pour cela la fonction slice()) ;\ncréer une 2ème table qu’on appellera ‘col3’ qui comportera la 1ère colonne avec les intitulés des PCS et la colonne ‘dont actifs ayant un emploi’, attention le champ n’est donc pas tout à fait le même ;\njoindre ces deux tables et appliquer les fonctions gt() et suivantes pour la mise en forme du tableau final.\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\n# On va récupérer les libellés des modalités de la variable CS1 à partir du \n#  fichier meta :\nlevels_CS1 &lt;- meta[meta$COD_VAR==\"CS1\", ]$COD_MOD\nlabels_CS1 &lt;- meta[meta$COD_VAR==\"CS1\", ]$LIB_MOD\nRP_final &lt;- RP_final %&gt;% mutate(CS1_moda=factor(CS1, levels = levels_CS1, \n                                                labels = labels_CS1))\n\ncol2 &lt;- RP_final %&gt;% \n  filter(DEPT == \"75\" & !AGEREVQ %in% c(\"0\", \"5\", \"10\", \"65\", \"70\", \"75\", \"80\",\n                                        \"85\", \"90\", \"95\", \"100\", \"105\", \"110\",\n                                        \"115\", \"120\") &\n           TACT %in% c(\"11\", \"12\")) %&gt;% \n  count(CS1_moda, wt=IPONDI) %&gt;% \n  mutate(n=round(n)) %&gt;% \n  rename('2019'=n, 'PCS'=CS1_moda) %&gt;% \n  adorn_totals(\"row\") %&gt;% \n  slice(-7)\n\ncol3 &lt;- RP_final %&gt;% \n  filter(DEPT == \"75\" & !AGEREVQ %in% c(\"0\", \"5\", \"10\", \"65\", \"70\", \"75\", \"80\",\n                                        \"85\", \"90\", \"95\", \"100\", \"105\", \"110\", \n                                        \"115\", \"120\") &\n           TACT %in% c(\"11\")) %&gt;% \n  count(CS1_moda, wt=IPONDI) %&gt;% \n  mutate(n=round(n)) %&gt;% \n  rename('dont actifs ayant un emploi'=n, 'PCS'=CS1_moda) %&gt;% \n  adorn_totals(\"row\")\n\ncol2 %&gt;% left_join(col3) %&gt;%  \n  gt()  %&gt;% \n  fmt_number(columns = c(2,3), sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population active de 15-64 ans selon la \n             catégorie socioprofessionnelle en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\n# On supprime les tableaux intermédiaires\nrm(col2, col3)\n\n\n\n\nA Paris, la population active comprend en 2019 plus de 500 000 personnes appartenant à la catégorie “cadres et professions intellectuelles supérieures”, des 2 colonnes on peut en déduire qu’il y a environ 31 000 personnes relevant de cette PCS qui sont au chômage. Les cadres sont suivis des professions intermédiaires (plus de 260 000 actifs) et des employés (quasi 220 000). Il y a très peu d’agriculteurs exploitants, ce qui semble assez logique sur le territoire de Paris !",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quelles questions intéressantes pour une \"fouille de données\" sur la base des RP ?</span>"
    ]
  },
  {
    "objectID": "05-Questions-fouille-donnees.html#caractéristiques-des-logements-parisiens",
    "href": "05-Questions-fouille-donnees.html#caractéristiques-des-logements-parisiens",
    "title": "5  Quelles questions intéressantes pour une “fouille de données” sur la base des RP ?",
    "section": "5.3 Caractéristiques des logements parisiens",
    "text": "5.3 Caractéristiques des logements parisiens\nEnfin, pour donner un exemple sur l’étude des caractéristiques des logements parisiens, essayons de même de reproduire le tableau de l’Insee ci-dessous. Souvenez-vous que cette base a plusieurs unités statistiques/niveaux : individus, logements/ménages, etc. Il faut donc faire attention :\n\nau champ du tableau donc les filtres à utiliser ici ;\nà avoir d’abord les moyennes sur ces deux types de logements, donc uiliser à la suite les fonctions group_by() et summarise() ;\nà ajouter ensuite une ligne sur l’ensemble des résidences principales avec la fonction bind_rows() ;\nà changer les dénominations des colonnes et des modalités, avec les fonctions du package gt() comme cols_label() ou text_case_match().\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nRP_final %&gt;% \n  filter(DEPT == \"75\" & LPRM==\"1\" & CATL==\"1\" & TYPL %in% c(\"1\", \"2\")) %&gt;% \n  group_by(TYPL) %&gt;%\n  summarise(Moy_pieces = weighted.mean(as.numeric(as.character(NBPI)), \n                                       IPONDI, na.rm=T)) %&gt;%\n  bind_rows(summarise(TYPL = \"Ensemble des résidences principales\", \n                      RP_final[RP_final$DEPT == \"75\" & RP_final$LPRM==\"1\" & \n                                 RP_final$CATL == \"1\" & RP_final$TYPL %in% c(\"1\", \"2\"), ], \n                      Moy_pieces = weighted.mean(as.numeric(as.character(NBPI)), \n                                                 IPONDI, na.rm=T))) %&gt;%\n  gt() %&gt;% \n  fmt_number(columns = 2, dec_mark = \",\", decimals = 1) %&gt;% \n  cols_label(TYPL=\"Type de logement\", Moy_pieces=\"2019\") %&gt;% \n  text_case_match(\"1\" ~ \"Maison\", \"2\" ~ (\"Appartement\")) %&gt;% \n  tab_header(title = \"Nombre moyen de pièces des résidences principales\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\n\n\n\nAinsi, si l’on veut créer des tableaux de répartition à une seule variable, on peut utiliser ces procédures qui se structurent toujours de la même façon. Au lieu de faire un copié-collé du code et de changer le nom des variables, autrement dit pour systématiser nos procédures, une astuce est de créer ses propres fonctions. C’est ce que nous allons étudier maintenant.",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quelles questions intéressantes pour une \"fouille de données\" sur la base des RP ?</span>"
    ]
  },
  {
    "objectID": "06-Fonctions.html",
    "href": "06-Fonctions.html",
    "title": "6  Systématiser nos procédures : construire une fonction",
    "section": "",
    "text": "6.1 Principes généraux d’une fonction\nPour ré-utiliser un code de façon plus automatique, créer des fonctions est très utile (et on peut même les stocker dans un fichier .r pour les réutiliser plus tard pour une autre étude).\nL’idée est qu’à partir d’un bloc d’instructions ou de lignes de codes, on l’intègre dans une fonction qui portera un nom et qui pourra être appliquée sur les paramètres que l’on veut (table/objet différent, variables différentes) et qui nous retournera une valeur en sortie (qu’il faut préciser donc). Par exemple :\n# Exemple fonction avec 3 arguments\nnom_fonction &lt;- function(data, var1, var2) {\n  \n  expression...  # Ce que la fonction fait\n  \n  return()  # Optionnel, mais la plupart du temps utilisé (!), \n               # pour sortir le résultat de la fonction\n  \n}\n\n# L'appel de la fonction devra ainsi préciser la table de données sur laquelle \n# l'appliquer et les autres arguments : \nnom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1,  \n             var2 = nom_de_ma_variable2)\n\n# De plus, on pourra créer un nouvel objet (ici \"tab_var\") pour stocker la table \n# qui est en valeur de sortie de la fonction : \ntab_var &lt;- nom_fonction(data = nom_de_ma_table , var1 = nom_de_ma_variable1,\n                        var2 = nom_de_ma_variable2)\nLes arguments doivent donc être précisés en entrée de notre fonction, si on ne les précise pas cela nous retournera une erreur… à moins que l’on ait spécifié des valeurs par défaut (ce qui peut être utile si on utilise souvent les mêmes paramètres, par exemple la même base de données) ; il peut y avoir autant d’arguments que l’on souhaite.\nSi l’on utilise le langage tidyverse, il faut connaître quelques petits “trucs” pour écrire une fonction. Le schéma suivant réalisé par Julien Barnier du CNRS nous sera très utile.\nSource : Julien Barnier, https://twitter.com/lapply/status/1493908215796535296?s=20&t=p4aYIEV4GsGS3TGftPa0Nw.\nVous trouverez également des informations utiles ici ou là.",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Systématiser nos procédures : construire une fonction</span>"
    ]
  },
  {
    "objectID": "06-Fonctions.html#exemples-de-fonctions",
    "href": "06-Fonctions.html#exemples-de-fonctions",
    "title": "6  Systématiser nos procédures : construire une fonction",
    "section": "6.2 Exemples de fonctions",
    "text": "6.2 Exemples de fonctions\nOn peut d’abord créer une fonction reprenant le code de la section précédente pour la construction de tableau. On l’appelle tableau, et on lui donne comme arguments “data”, “filtre_dept”, “var_quali”, “pond” et “nom_var_quali”.\nDans le langage tidyverse, au sein d’une fonction, il faut appeler une variable avec des doubles-accolades {  }.\nSi l’on utilise une fonction summarise(), une autre subtilité à connaître est que cette syntaxe summarise({{ nom_var }} = mean({{ var }}, na.rm=TRUE)) ne sera pas reconnue, car il faut indiquer non pas un = mais un := pour que la fonction puisse être lue lorsque le nom donné à la variable est de type caractère ou “string”.\nEnfin, il ne faut pas oublier de retourner un objet en sortie avec return().\nEssayez donc de créer une fonction tableau(), reprenant le premier code de la section précédente et remise ci-dessous pour information :\n\nRP_final %&gt;% \n  filter(DEPT == \"75\") %&gt;% \n  mutate(SEXE_moda=case_when(SEXE==\"1\" ~ \"Hommes\", SEXE==\"2\" ~ \"Femmes\")) %&gt;% #ne pas mettre cette ligne dans la fonction\n  count(SEXE_moda, wt=IPONDI) %&gt;% \n  mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% \n  adorn_totals(\"row\") %&gt;% \n  rename(Effectif=n, 'Sexe'=SEXE_moda) %&gt;% \n  gt() %&gt;% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population par sexe en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\ntableau &lt;- function(data, filtre_dept, var_quali, pond=IPONDI, nom_var_quali){\n  \n  tab &lt;- data %&gt;% \n    filter(DEPT == filtre_dept) %&gt;% \n    count({{ var_quali }}, wt={{ pond }}) %&gt;% \n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% \n    adorn_totals(\"row\") %&gt;% \n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n  \n  return(tab)\n  \n}\n\n\n\n\nOn peut vérifier qu’on obtient bien la même chose :\n\nRP_final %&gt;% \n  mutate(SEXE_moda=case_when(SEXE==\"1\" ~ \"Hommes\", SEXE==\"2\" ~ \"Femmes\")) %&gt;% \n  tableau(filtre_dept=\"75\", var_quali=SEXE_moda, nom_var_quali=\"Sexe\") %&gt;% \n  gt() %&gt;% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population par sexe en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\n\n\n\n\n\n\nPopulation par sexe en 2019\n\n\nSexe\nEffectif\nPourcentage\n\n\n\n\nFemmes\n1 146 436\n52.9\n\n\nHommes\n1 019 195\n47.1\n\n\nTotal\n2 165 631\n100.0\n\n\n\nSource : Insee, RP 2019 ; Champ : Paris.\n\n\n\n\n\n\n\n\nOn a gagné 5 lignes de codes !\nSi on a plusieurs filtres à mettre, comme on a pu le voir avec le 2nd tableau, on peut utiliser l’argument “…” (lire “dot”) : cet argument est très pratique si l’on ne sait pas combien il y aura de variable(s) dans la fonction à laquelle elle s’applique, c’est-à-dire autant 0 variable, 1 variable ou plus d’une variable ; mais elle peut aussi être “dangereuse” si on ne se souvient plus qu’on l’a créée et/ou si on ne fait pas attention à bien remplir les autres arguments avec les noms correspondants. Si on réécrit la fonction tableau et qu’on l’applique au 2nd tableau créé précédemment, cela donnerait ceci :\n\ntableau &lt;- function(data, ..., var_quali, pond=IPONDI, nom_var_quali){\n  \n  tab &lt;- data %&gt;% \n    filter(...) %&gt;% \n    count({{ var_quali }}, wt={{ pond }}) %&gt;% \n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;% \n    adorn_totals(\"row\") %&gt;% \n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n  \n  return(tab)\n  \n}\n\nRP_final %&gt;% \n  mutate(TACT_moda=case_when(TACT == \"11\" ~ \"Actifs ayant un emploi\",\n                             TACT == \"12\" ~ \"Chômeurs\",\n                             TACT == \"22\" ~ \"Élèves, étudiants et stagiaires non rémunérés\",\n                             TACT == \"21\" ~ \"Retraités ou préretraités\",\n                             TRUE ~ \"Autres inactifs\"),\n         TACT_moda=fct_relevel(TACT_moda, c(\"Actifs ayant un emploi\", \"Chômeurs\",\n                                            \"Élèves, étudiants et stagiaires non rémunérés\", \n                                            \"Retraités ou préretraités\", \"Autres inactifs\"))) %&gt;% \n  tableau(DEPT == \"75\" & !AGEREVQ %in% c(\"0\", \"5\", \"10\", \"65\", \"70\", \"75\", \"80\", \"85\", \"90\", \"95\", \n                                        \"100\", \"105\", \"110\", \"115\", \"120\"),\n          var_quali=TACT_moda, nom_var_quali=\"Type d'activité\") %&gt;% \n  gt() %&gt;% \n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population de 15-64 ans par type d'activité en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\n\n\n\n\n\n\nPopulation de 15-64 ans par type d'activité en 2019\n\n\nType d'activité\nEffectif\nPourcentage\n\n\n\n\nActifs ayant un emploi\n1 042 588\n69.3\n\n\nChômeurs\n135 014\n9.0\n\n\nÉlèves, étudiants et stagiaires non rémunérés\n192 205\n12.8\n\n\nRetraités ou préretraités\n38 512\n2.6\n\n\nAutres inactifs\n95 944\n6.4\n\n\nTotal\n1 504 263\n100.1\n\n\n\nSource : Insee, RP 2019 ; Champ : Paris.\n\n\n\n\n\n\n\n\nUne autre façon de faire serait de créer un vecteur qui contiendrait ces différents filtres mais qu’il faudrait combiner dans une chaîne de caractères, ce qui est possible avec la fonction paste0(), et l’insérer ensuite dans la ligne de code dplir en utilisant eval(parse(text=)) pour convertir cette chaîne de caractéres en une expression (parse(text=)) pour que R puisse l’évaluer/le calculer avec la fonction eval().\n\ntableau_bis &lt;- function(data, vars_filtre, var_quali, pond=IPONDI, nom_var_quali){\n\n  text_filtre &lt;- paste0(\"(\", vars_filtre, \")\", collapse = \" & \")\n\n  tab1 &lt;- data %&gt;%\n    filter(eval(parse(text = text_filtre))) %&gt;%\n    count({{ var_quali }}, wt={{ pond }}) %&gt;%\n    mutate(Pourcentage=round(prop.table(n)*100, 1)) %&gt;%\n    adorn_totals(\"row\") %&gt;%\n    rename(Effectif=n, {{nom_var_quali}}:={{ var_quali }}) \n\n  return(tab1)\n\n}\n\n# Attention, comme les filtres sont contenues dans des \" \", il faut à l'intérieur des  \n#  filtres utiliser les ' ' plutôt que les \" \"\nmes_filtres &lt;- c(\"DEPT == '75'\", \"!AGEREVQ %in% c('0', '5', '10', '65', '70', '75', \n                                                  '80', '85', '90', '95', '100', '105',\n                                                  '110', '115', '120')\")\n\nRP_final %&gt;% \n  mutate(TACT_moda=case_when(TACT == \"11\" ~ \"Actifs ayant un emploi\",\n                             TACT == \"12\" ~ \"Chômeurs\",\n                             TACT == \"22\" ~ \"Élèves, étudiants et stagiaires non rémunérés\",\n                             TACT == \"21\" ~ \"Retraités ou préretraités\",\n                             TRUE ~ \"Autres inactifs\"),\n         TACT_moda=fct_relevel(TACT_moda1, c(\"Actifs ayant un emploi\", \"Chômeurs\",\n                                            \"Élèves, étudiants et stagiaires non rémunérés\", \n                                            \"Retraités ou préretraités\", \"Autres inactifs\"))) %&gt;% \n  tableau_bis(mes_filtres, var_quali=TACT_moda, nom_var_quali=\"Type d'activité\") %&gt;%\n  gt() %&gt;%\n  fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n  tab_header(title = \"Population de 15-64 ans par type d'activité en 2019\") %&gt;% \n  tab_source_note(source_note = \"Source : Insee, RP 2019 ; Champ : Paris.\")\n\nOn peut également créer une fonction pour permettre de récupérer plus rapidement les libellés des variables à partir du fichier de métadonnées :\n\n# Pour la fonction mutate, on est de nouveau obligé d'utiliser l'expression \n#  'eval(parse(text={{ cod_var }}))' sinon R ne comprend pas que la variable \n#  utilisée est une expression de type caractère\nlibelles_var &lt;- function(data, cod_var, new_var){\n  \n  levels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD\n  labels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD\n  data %&gt;% mutate({{ new_var }} := factor(eval(parse(text={{ cod_var }})), \n                                          levels = levels_var, labels = labels_var))\n\n}\n\n\n# Autre possibilité, utiliser la fonction `sym()` (qui crée un symbole à partir \n# d'une chaîne de caractères) avec les \"!!\" (opérateur bang-bang qui permet de \n# forcer l'évaluation d'une partie d'une expression avant le reste) : \n\n# libelles_var &lt;- function(data, cod_var, new_var){\n#   \n#   levels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$COD_MOD\n#   labels_var &lt;- meta[meta$COD_VAR=={{ cod_var }}, ]$LIB_MOD\n#   data %&gt;% mutate({{ new_var }} := factor(!!sym({{ cod_var }}), \n#                                           levels = levels_var, \n#                                           labels = labels_var))\n#   \n# }\n\nEnfin, essayez d’écrire une seconde fonction somme() permettant de systématiser le code utilisée en fin de 1ère séance et qui donnait un tableau de contingence du nombre de personnes caractériées par son statut par commune (cela nous servira pour plus tard…) ; le voici pour rappel :\n\nRP_final %&gt;% \n  group_by(COM) %&gt;%\n  count(TACT, wt=IPONDI) %&gt;% \n  mutate(n=round(n)) %&gt;% \n  pivot_wider(names_from = TACT, values_from = n)\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nsomme &lt;- function(data, var_gpe, nom_var){\n  \n  som &lt;- data %&gt;% \n    group_by({{var_gpe}}) %&gt;% \n    count({{nom_var}}, wt=IPONDI) %&gt;% \n    mutate(n=round(n)) %&gt;% \n    pivot_wider(names_from = {{nom_var}}, values_from = n)\n  \n  return(som)\n  \n}\n\n\n\n\nVérifions :\n\nsomme(data=RP_final, COM, TACT)\n\n# A tibble: 137 × 8\n# Groups:   COM [137]\n   COM    `11`  `12`  `21`  `22`  `23`  `24`  `25`\n   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 75101  8366   941  2630  1423  1628   252   676\n 2 75102 13118  1378  2148  1617  2499   272   576\n 3 75103 19239  2085  4589  2947  3630   446  1100\n 4 75104 15227  1863  4508  2764  3268   480  1000\n 5 75105 27378  2611 10607  9138  6189   923  1369\n 6 75106 18073  1842  8180  6326  3742  1097  1012\n 7 75107 23394  2165  9573  5659  5312  1652  1112\n 8 75108 18254  1565  5297  3999  4693  1063   779\n 9 75109 34155  3482  7264  5201  7656   892  1377\n10 75110 46454  6343 10645  7083 11481  1241  3273\n# ℹ 127 more rows\n\n\nLa création de fonctions est donc très utile pour avoir un code plus efficace ; il faut toutefois réfléchir à son usage avant de la créer pour savoir à quel point il faut systématiser les procédures utilisées, certains éléments devant être laissés probablement en-dehors de la fonction, comme dans l’exemple précédent le fait d’arrondir les chiffres. Il faut par ailleurs toujours vérfier, sur un ou deux exemples, que la fonction fonctionne bien, c’est-à-dire donne les mêmes résultats que le code initial.\nPour pouvoir les réutiliser ultérieurement, on peut les réécrire dans un nouveau script qu’on enregistre dans un dossier de notre projet qu’on intitule “fonctions” ; il suffira ensuite d’appeler ce programme avec la fonction source() :\n\nsource(\"fonctions/fonctions.R\")",
    "crumbs": [
      "Séance2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Systématiser nos procédures : construire une fonction</span>"
    ]
  },
  {
    "objectID": "07-Ggplot-theorique.html",
    "href": "07-Ggplot-theorique.html",
    "title": "7  Data Visualization et Ggplot2 : aspects théoriques",
    "section": "",
    "text": "7.1 Présentation générale de Ggplot2\nLe package ggplot2 (inclus dans le package tidyverse) est l’un des atouts de R et permet de réaliser de beaux graphiques ; vous en trouverez ici la présentation officielle. L’inconvénient, surtout pour quelqu’un qui serait habitué à construire des graphiques sous excel, est qu’il faut (presque) tout paramétrer, ce qui peut finalement donner un code très long.\nL’architecture globale de ggplot2 est souvent représentée par le schéma ci-dessous :\nPour le lire, il faut partir du bas du schéma :",
    "crumbs": [
      "Séance 3",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Visualization et Ggplot2 : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "07-Ggplot-theorique.html#présentation-générale-de-ggplot2",
    "href": "07-Ggplot-theorique.html#présentation-générale-de-ggplot2",
    "title": "7  Data Visualization et Ggplot2 : aspects théoriques",
    "section": "",
    "text": "par “Data”, nous devons d’abord préciser la base ou le tableau de données utilisé(e) qui contient la ou les variables qui seront représentées ;\npar “aesthetics”, nous allons ensuite indiquer les variables qui seront projetées sur le graphe ;\npar “geometries”, nous indiquons le type de graphique utilisé ou la forme géométrique ;\npar “facets”, nous pouvons éventuellement (facultatif donc) diviser ou découper le graphique en plusieurs graphes (ou “panneaux”) dépendant d’une autre variable par exemple ;\npar “statistics”, nous pouvons là aussi éventuellement ajouter des statistiques ;\npar “coordinates”, nous pouvons là aussi éventuellement changer le sens du graphique ;\nenfin, par “theme”, nous pouvons utiliser éventuellement l’un des thèmes graphiques diponibles et/ou ajouter un certain nombre d’options sur ce qui “entoure” le graphique, c’est-à-dire les positions et/ou couleurs et/ou taille, etc., des axes, titre, légende, etc.\n\n\n7.1.1 Les “aesthetics” ou arguments esthétiques\nIl s’agit principalement d’indiquer quelle variable sera utilisée en abcisse (x=), et laquelle sera éventuellement utilisée en ordonnée (y=).\nMais on peut aussi ajouter des variables supplémentaires qui seront différenciées par :\n\ncouleur, avec color= (pour des points, lignes ou symboles) ou fill= (pour le contenu des bâtons ou symboles) ;\ntaille avec size= ;\nsymboles avec shape= ;\ntype de lignes avec linetype= ;\ndegré de transparence avec alpha= (mais non conseillé pour les variables discrètes).\n\nLa nuance à bien comprendre est qu’utiliser ces options à l’intérieur de la fonction aes() revient à ajouter une 3ème variable (une légende apparaîtra alors automatiquement), alors que si l’on veut simplement changer l’aspect des points, lignes, barres, etc., d’une variable déjà projetée, il faut appeler (souvent) ces mêmes options après la fonction aes() à l’intérieur de la fonction geom_***() par exemple. Dans ce cas-là, on peut changer la couleur des points avec color= , la taille des points ou lignes avec size=, l’épaisseur des barres avec width=, etc. C’est la différence entre le “mapping” et les “settings”.\nChacune de ces options ont des modalités différentes, il peut être bien d’avoir des mémos rangés dans un dossier créé pour cela pour éviter de les chercher à chaque fois.\nPar exemple, pour les couleurs, vous trouverez un mémo pdf ici, ou un bon récapitulatif là. On peut également utiliser la fonction colours() dans R pour voir la liste complète des couleurs standard.\nPour la liste des symboles (“shape”) et le numéro correspondant que l’on appelera avec l’argument shape=, ci-dessous un récapitulatif : \nEt voici pour la liste des types de lignes, avec linetype= : \n\n\n7.1.2 Les géométries\nUne fois les variables appelées, il faut définir le type de graphique. Il y a beaucoup de choix possibles inclus dans ggplot2, le tout est de bien comprendre quel type de graphique convient le mieux à ou aux variables utilisées et à ce que l’on veut montrer (cf. section suivante sur les grands principes de la data visualization). Voici un tableau récapitulant les principales “geometries”.\n\nTableau : Les principales fonctions “geometries” de Ggplot\n\n\n\n\n\n\n\nFonction\nType de graphique\nType de variable(s)\n\n\n\n\ngeom_histogram()\nHistogramme\n1 variable continue\n\n\ngeom_density()\nCourbe de densité\n1 variable continue\n\n\ngeom_area()\nGraphique en aires empilées\n1 variable continue\n\n\ngeom_col()\nGraphique en bâtons\n1 variable discrète\n\n\ngeom_point()\nNuage de points\n2 variables continues\n\n\ngeom_jitter()\nNuage de points dispersés\n2 variables continues\n\n\ngeom_boxplot()\nBoîte à moustache\n1 variable continue, sans ou avec 1 variable discrète\n\n\ngeom_violin()\nGraphes en violon\n1 variable continue, sans ou avec 1 variable discrète\n\n\ngeom_bar()\nGraphique en bâtons\n1 variable continue, sans ou avec 1 variable discrète\n\n\ngeom_line()\nLignes\nFonction continue selon une variable de date\n\n\ngeom_area()\nGraphique en aires empilées\nFonction continue selon une variable de date\n\n\n\nCertaines d’entre elles ont des options à préciser, presque de façon obligatoire comme nous l’avons déjà vu avec geom_histogram() et l’option bins=, si elle n’est pas précisée, elle sera “forcée” par R mais un message d’avertissement en rouge apparaîtra.\nIl en existe bien sûr plein d’autres, il faut dans ce cas rechercher sur internet ou aller voir sur la “cheatsheet” de ggplot2 disponible sur internet.\nIl est possible de faire suivre plusieurs fonctions geom_***() : par exemple un geom_line() après un geom_point(), un geom_text() après un geom_bar(), etc. Dans ce cas, des variables supplémentaires peuvent être ajoutées (ou remplacer les précédentes) avec une nouvelle fonction aes à l’intérieur de ce geom_***() ; un exemple assez courant est la construction d’un graphique en bâtons avec l’ajout des valeurs de la variable à l’intérieur des bâtons (ou juste au-dessus), on fera alors appel à deux fonction geom_***() comme ceci : data %&gt;% ggplot() + aes(x=, y=) + geom_bar() + geom_text(aes(label=)). De même, il est possible de spécifier des données (data) différentes pour chaque geom_***() .\n\n\n7.1.3 Les facettes\nIl y a deux types de facettes (en réalité trois, avec celle par défaut qui s’intitule facet_null() et produit un seul graphe) :\n\nfacet_wrap() : produit une suite de graphiques et a un argument principal facets=vars() et éventuellement ncol= et nrow= ;\nfacet_grid() : produit une grille ou matrice de graphiques définies par une ou deux variables qui forment les lignes et les colonnes, définies avec les deux arguments principaux cols= et row=, ou en indiquant un ~ entre les deux variables.\nÀ savoir, il y a des options pour contrôler les échelles avec l’argument scales=.\nLes facettes sont ainsi une autre façon, par rapport aux “aesthetics”, de représenter deux variables par rapport à une troisième variable.\n\n\n\n7.1.4 Les statistiques\nOn peut vouloir ajouter sur un graphique des statistiques particulières ou supplémentaires, comme la moyenne ou médiane d’une variable quantitative, ou encore représenter la régression linéaire dans le cas d’une variable fonction d’une autre, etc.\nPar exemple, si l’on projette des boîtes à moustache, la moyenne n’étant pas affichée on peut la rajouter avec la fonction stat_summary() et l’option fun = mean.\nSi l’on souhaite ajouter une régression linéaire sur un graphique de nuage de points, il faut utiliser la fonction geom_smooth() et l’option method=lm.\nCertaines statistiques peuvent aussi être calculées ou transformées directement dans certaines fonctions : c’est par exemple le cas avec la fonction geom_histogramm() où l’on peut produire un histogramme de la densité en spécifiant y=..density.. dans l’aes() ou en la superposant à l’aide d’une courbe à l’histogramme initial en ajoutant alors ensuite un geom_density() ; ou encore avec la fonction geom_bar() avec les arguments stat = \"summary_bin\", fun = mean (par défaut, stat = \"count\", dans ce cas la hauteur des barres représente le comptage des cas dans chaque catégorie).\n\n\n7.1.5 Les coordonnées\nLes systèmes de coordonnées linéaires permettent de changer le sens du graphique ou de “zoomer” sur le graphique :\n\ncoord_cartesian() : c’est le système de coordonnées par défaut (repère “cartésien”), en changeant les arguments xlim= ou ylim=, on procède à un zoom sur l’axe des abscisses et/ou celui des ordonnées ; cela permet de ne pas supprimer des données comme le ferait les fonctions scale_x_continuous() ou scale_y_continuous mais juste de ne pas les afficher sur le graphe ;\ncoord_flip() : permet d’inverser les axes ;\ncoord_fixed() : produit un système de coordonnées cartésiennes avec un “ratio d’aspect” fixe.\n\nIl existe également des systèmes de coordonnées non-linéaires, comme coord_polar() par exemple.\n\n\n7.1.6 Les thèmes\nIl y a plusieurs thèmes existants dans le package ggplot2, theme_gray() est le thème par défaut ; les autres sont présentés dans la figure ci-dessous. \nEnsuite, la fonction theme() permet de modifier les aspects du graphique : il y a un certain nombre d’arguments disponibles qui permettent de modifier les éléments entourant le graphique comme les titre et sous-titre, les éléments à l’intérieur du graphique c’est-à-dire de la grille, les éléments des axes, ou encore les éléments de la légende (ou sa position sur la figure), etc.\nLa figure ci-dessous est une bonne synthèse de la manière dont il faut programmer ces différentes éléments du thème d’un graphique (téléchargeable directement ici) :\n\n\n\n7.1.7 Les autres options graphiques : titres, échelles des axes, etc.\nPour le titre général, mais aussi les titres des axes, ainsi qu’une éventuelle légende, source, etc., on peut les rassembler dans la fonction labs() :\n\nlabs(\n  title    = \" \",\n  subtitle = \" \",\n  x        = \" \",\n  y        = \" \",\n  caption  = \" \")\n\nLes axes des échelles peuvent être changés, ainsi que les valeurs affichées, avec les fonctions scale : si les variables sont quantitatives/continues, avec scale_x_continous() et scale_y_continuous() ; si les variables sont qualitatives/discrètes, avec scale_x_discrete() et scale_x_discrete() ; dont les options les plus souvent utilisées sont limits=, breaks=, labels=, ou encore trans= qui permet de transformer la mesure de l’échelle (exponentielle, log, …). Lorsqu’une option fill= ou color= est utilisée dans un aes, alors on peut modifier le type de couleurs ou palettes utilisées avec par exemple scale_fill_brewer() pour la pallette de couleur RBrewer ou scale_fill_viridis() pour la palette Viridis, etc.\nIl y a encore d’autres fonctions qui permettent de “customiser” à votre goût un graphique ggplot, il faut s’aventurer dans les diverses documentations plus complètes sur le package ggplot2.\n\n\n7.1.8 Code minimal\nAprès l’appel de la fonction ggplot(), chaque “couche” supplémentaire utilisée est précisée par le signe + et non l’habituel pipe %&gt;% pour bien signifier qu’on est toujours dans la fonction ggplot(), par ailleurs il faut faire attention de mettre le signe + à la fin d’une ligne et ensuite de faire un saut de ligne (le contraire saut de ligne et début de la ligne suivante avec le + ne fonctionnera pas). Les trois arguments obligatoires sont donc les 3 premières : “data”, “aesthethics” et “geometries”. En langage tidyverse, il existe plusieurs façons d’écrire le code :\n\n# Les 4 façons d'écrire suivantes sont similaires :\ndata %&gt;%              # on spécifie la table de données\n  ggplot() +          # on appelle la fonction ggplot()\n  aes(x = , y = ) +   # on spécifie dans l'aes() les variables à mettre dans l'axe  \n                      #         des abcisses (x=) et dans l'axe des ordonnées (y=)\n  geom_histogram()    # on trace l'histogramme\n\ndata %&gt;% ggplot(aes(x = , y = )) + geom_histogram() \nggplot(data) + aes(x = , y = ) + geom_histogram() \nggplot(data, aes(x = , y = ))  + geom_histogram()\n\nNous privilégierons ici la 1ère d’entre elles, mais vous pouvez en choisir une autre !\n\n\n7.1.9 Liens utiles pour aller plus loin\nNous ne pouvons pas résumer l’ensemble des possibilités données par ggplot2 ; il faudra donc rechercher par soi-même si besoin. Voici pour cela deux sites très complets sur le package :\n\nhttps://ggplot2-book.org/toolbox.html\n\nhttps://bookdown.org/ael/rexplor/chap8.html#aes",
    "crumbs": [
      "Séance 3",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Visualization et Ggplot2 : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "07-Ggplot-theorique.html#les-grands-principes-de-data-visualization",
    "href": "07-Ggplot-theorique.html#les-grands-principes-de-data-visualization",
    "title": "7  Data Visualization et Ggplot2 : aspects théoriques",
    "section": "7.2 Les grands principes de data visualization",
    "text": "7.2 Les grands principes de data visualization\nSans prétendre, ni pouvoir, faire un cours complet de data visualization, voici quelques grands principes à essayer de respecter quand on souhaite représenter graphiquement des résultats issus du traitement de données :\n\nsavoir au préalable le message principal que l’on souhaite faire passer : cela peut sembler évident, mais il faut toujour avoir cela en tête ;\nconstruire un graphique intelligible par le plus grand nombre : des graphiques trop sophistiqués, trop chargés d’informations, etc., ne permettront pas de transmettre le message souhaité. Cela peut bien sûr varier selon le public, mais… ;\nsituer le graphique : avec un titre explicite, éventuellement un sous-titre, ensuite avec une légende reprenant le champ et/ou la source, etc. ;\nchoisir le “bon” graphique selon le type de variables à représenter : variable continue ou discrète, croisement d’un type de variable avec un autre type, variables dépendant du temps (évolution), etc. ;\nprésenter le graphique de manière la plus objective possible : ne pas “tordre” le graphique pour faire apparaître un résultat qui n’est pas si évident que cela (c’est typiquement l’exemple d’un changement d’échelle ; d’un “zoom” sur l’axe des ‘y’ sur un graphique en évolution par exemple, pour montrer des variations qui ne seraient pas visibles si l’axe commençait à 0) ;\nrajouter des informations (étiquettes de nom, valeur, etc.) sans trop surcharger le graphique néanmoins ;\nêtre logique dans la contruction des éléments extérieurs au graphe : par exemple, ordre des modalités d’une légende située à droite selon le point d’arrivée des courbes ; ordre des modalités d’une variable discrète (par exemple le niveau de diplôme) ou selon la moyenne/médiane d’une autre variable par ordre croissant ou décroissant ; utiliser (le plus possible) des axes similaires pour comparer deux grahes côte à cote.\n\nCe chapitre de cours donne des conseils synthétiques : cf. ici ; ou cet article-là.",
    "crumbs": [
      "Séance 3",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data Visualization et Ggplot2 : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "08-Ggplot-pratique.html",
    "href": "08-Ggplot-pratique.html",
    "title": "8  Data Mining et Data Visualization en pratique",
    "section": "",
    "text": "8.1 Exemple de la construction d’un graphique pas à pas\nReprenons la base de données sur les offres d’emplois de Pôle emploi (devenu France Travail) de l’année 2020 disponibles sur Paris et la petite couronne, et commençons notre analyse descriptive des informations présentes dans cette base en construisant des graphiques pour répondre à certaines questions relatives à ces ces offres d’emploi. On pourra ainsi étudier l’évolution au cours de l’année de ces offres d’emplois.\nOn va chercher à représenter la distribution de la durée des contrats (pour rappel exprimée en jours) pour les offres d’emplois en contrat à durée déterminée (CDD) et en intérim (MIS) en fonction du mois. Notre variable principale est donc contractDuration_value, et la variable “secondaire” ou fonction de la première sera à construite à partir de la date de publication de l’offre date_sitePublicationDay.\nPour représenter la distribution d’une variable quantitative ou continue, on peut utiliser un histogramme (ou/et une courbe de densité), mais comme ici on veut la représenter selon une autre variable peut-être serait-il mieux d’utiliser une boîte à moustache qui donnera les principaux éléments de description de la distribution de cette variable.\nNous avons déjà vu ces deux graphiques précédemment, mais reprenons-les pour voir dans le détail comment nous les construisons !\nD’abord, on va créer une boîte à moustache pour représenter la distribution de la variable contractDuration_value:\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\")) %&gt;% \n  ggplot() + aes(x = contractDuration_value) + geom_boxplot()\nComme il reste des valeurs aberrantes (cf. section 3.2.3. de la séance 1 de ce cours) et des valeurs manquantes (objet de l’“Avis”), il faut un peu nettoyer la base, regardons plus précisément ces valeurs aberrantes en haut de la distribution :\n# Pour revoir cette distribution\nOffresPE_2020 %&gt;% filter(contractType %in% c(\"CDD\", \"MIS\")) %&gt;% \n  arrange(desc(contractDuration_value)) %&gt;% \n  select(contractType, contractDuration_value, contractDuration_period, \n         contractDuration_min, contractDuration_max, job_title, entrepriseSecteur_NAF21) %&gt;% \n  head(10)\n\n   contractType contractDuration_value contractDuration_period\n1           CDD                  20656                    YEAR\n2           CDD                  20656                    YEAR\n3           CDD                   8262                    YEAR\n4           CDD                   8262                    YEAR\n5           CDD                   8262                    YEAR\n6           CDD                   8262                    YEAR\n7           CDD                   8262                    YEAR\n8           CDD                   8262                    YEAR\n9           CDD                   8262                    YEAR\n10          CDD                   6656                    YEAR\n   contractDuration_min contractDuration_max\n1                    90                   90\n2                    90                   90\n3                    36                   36\n4                    36                   36\n5                    36                   36\n6                    36                   36\n7                    36                   36\n8                    36                   36\n9                    36                   36\n10                   29                   29\n                                                                                       job_title\n1                                                      Assistant commercial ADV H/F (ref : ASDO)\n2                                                 Assistant ADV bilingue anglais (ref: YFDO) H/F\n3                                                                          Formation CIFRE - H/F\n4                                       CHARGE EMPLOI-FORMATION / ANIMATION ESPACE NUMERIQUE H/F\n5                                                         Juriste/Acheteur marchés publics (H/F)\n6                                                                  Un Médecin addictologue - H/F\n7  CHARGE DE MISSION POLE EMPLOI ET COMPÉTENCES AU SEIN DU SERVICE ACCOMPAGNEMENT A L'EMPLOI H/F\n8                         MEDECIN REFERENT/PEDIATRE DU SERVICE DES CRECHES DEPARTEMENTALES - H/F\n9                                          Développeur·se web en développement de logiciel (H/F)\n10                                                                 Technicien électronique (H/F)\n   entrepriseSecteur_NAF21\n1                         \n2                         \n3                         \n4                         \n5                         \n6                         \n7                         \n8                         \n9                         \n10\nOn voit qu’il y a vraisemblablement un problème pour les premières observations de ces valeurs aberrantes puisque la période dans laquelle la durée du contrat est exprimée (variable contractDuration_period) serait l’année, alors qu’il s’agit probablement plutôt de mois ou de jours étant donné les valeurs minimum et maximum, on va donc supprimer ces observations car il semble difficile de les modifier sans savoir quelle est la bonne temporalité dans laquelle elles sont exprimées et aussi car il ne s’agit que de 42 observations.\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;%\n  filter(!(contractType %in% c(\"CDD\", \"MIS\") & \n             contractDuration_period==\"YEAR\" &\n             contractDuration_value&gt;780))\n\n\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  ggplot() + aes(x = contractDuration_value) + geom_boxplot()\nC’est plus lisible, même s’il reste des valeurs élevées et supérieures à la durée maximale d’un CDD dans le secteur privée qui est de 18 mois, soit environ 549 jours, mais il est possible d’avoir des CDD plus longs dans la fonctions publique, nous pouvonr éventuellement rajouter un filtre sur le secteur d’activité pour éviter d’avoir des offres émanant de l’administration publique pour pouvoir comparer ce qui est comparable !\nOu nous pouvons procéder à des paramétrages supplémentaires pour que la boxplot soit davantage visible. On peut par exemple utiliser une option pour mettre une échelle moins grande en abcisse. Plusieurs manières de faire existent, mais l’une d’entre elles équivaut à supprimer les valeurs, alors qu’une autre permet de les garder et juste de ne pas les faire apparaître sur le graphique, cela peut-être important si ensuite nous voulons ajoutons des statistiques comme la moyenne sur le boxplot, comme nous allons le voir.\nLa première manière est d’utiliser l’argument scale_x_continuous() et l’option limits=c() pour indiquer les nouvelles valeurs de l’échelle, par exemple ici entre 1 et 2 000, mais un avertissement est alors donné : 1151 lignes ont été supprimées, si nous ajoutons ensuite la moyenne, elle sera calculée sans ces 1151 observations, cela peut donc changer les indicateurs de moyenne, voire de médiane, ce n’est donc pas rigoureux.\nUtilisons plutôt la seconde méthode maintenant, avec l’option xlim() à intégrer dans la fonction coord_cartesian() qui fait l’équivalent d’un zoom sur le graphique sans supprimer des observations :\n# 1ère méthode :\n# OffresPE_2020 %&gt;% filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;%\n#   ggplot() + aes(x = contractDuration_value) + geom_boxplot() +\n#   scale_x_continuous(limits = c(1, 550))\n\n# 2nde méthode plus rigoureuse :\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  ggplot() + aes(x = contractDuration_value) + geom_boxplot() + \n  coord_cartesian(xlim=c(0,550))\nEnsuite, nous souhaitons représenter la distribution de cette variable selon le mois de publication de l’offre) : nous allons pour cela créer une variable mois_publication à partir d’une fonction relative à la date puis nous l’ordonnons ; et nous allons en profiter pour préciser un peu l’échelle des abscisses (réduire le “pas” avec l’option breaks=seq() en mettant tous les 30 jours pour voir à peu près les mois) :\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  mutate(mois_publication = months(date_sitePublicationDay, abbreviate = T),\n         mois_publication = factor(mois_publication, \n                                   levels = c(\"déc.\",\"nov.\",\"oct.\",\"sept.\", \"août\", \"juil.\",\n                                              \"juin\",\"mai\",\"avr.\", \"mars\", \"févr.\", \"janv.\"))) %&gt;% \n  ggplot() + aes(x = contractDuration_value, y=mois_publication) + geom_boxplot() + \n  coord_cartesian(xlim=c(0,550))  + \n  scale_x_continuous(breaks=seq(0,550,30))\nOn voit que la médiane est plutôt stable entre les mois, sauf en mai et en avril, et par ailleurs les valeurs Q3 varient beaucoup entre les mois.\nNous pouvons également ajouter la moyenne, puisqu’ici nous voyons de gauche à droite, le minimum, le 1er quartile, la médiane, le 3ème quartile, le maximum et les “outliers” (points aberrants selon les statistiques de la boxplot). Pour cela, il faut utiliser la “couche” statistique de ggplot() avec la fonction stat_summary() et les options fun = mean pour la moyenne, geom = point pour qu’elle soit représentée par un point, color=\"gray50\" pour qu’elle se différencie des autres points et soit en gris, et éventuellement size=2 pour jouer sur la taille du point.\n# Pour infos, les options de `geom =` dans `stat_summary()` sont par exemple :  \n# \"point\", \"pointrange\", \"crossbar\", \"bar\" (cell-ci à ne pas utiliser ici néanmoins !)\n\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  mutate(mois_publication = months(date_sitePublicationDay, abbreviate = T),\n         mois_publication = factor(mois_publication, \n                                   levels = c(\"déc.\",\"nov.\",\"oct.\",\"sept.\", \"août\", \"juil.\",\n                                              \"juin\",\"mai\",\"avr.\", \"mars\", \"févr.\", \"janv.\"))) %&gt;% \n  ggplot() + aes(x = contractDuration_value, y=mois_publication) + \n  geom_boxplot() + \n  stat_summary(fun=mean, geom=\"point\", color=\"gray50\", size=2) +\n  coord_cartesian(xlim=c(0,550))  + \n  scale_x_continuous(breaks=seq(0,550,30))\nOn observe ainsi des différences entre la moyenne et la médiane, puisque la moyenne est toujours supérieure à la médiane puisque tirée par des valeurs plus souvent très élevées que très faibles (plus de points au-delà du maximum que l’inverse), mais elle semble moins varier selon les mois.\nOn peut aussi vouloir enlever les outliers avec l’option outlier.shape de geom_boxplot() comme ceci : geom_boxplot(outlier.shape = NA).\nOn peut encore vouloir ordonner l’affichage des années par ordre décroissant de la médiane ou de la moyenne (ordre décroissant ici = valeur la plus élevée en haut du graphique). Nous pouvons, entre autres, utiliser pour cela la fonction fct_reorder() du package forcats déjà présenté dans la section 3.2 de ce cours (Séance 1) : nous pouvons alors directement l’intégrer dans l’aes de ggplot dans la variable en ordonnée y=fct_reorder(), il faut pour cela mettre entre parenthèses la variable utilisée en ordonnée, suivie de la variable par laquelle on ordonne (la même que celle utilisée dans x=). Utilisée dans un boxplot, cela ordonne par défaut selon la médiane ; si on veut que les régions soient ordonnées par la moyenne, il faut rajouter l’option .fun=mean dans la fonction fct_reorder(), cf. le code en-dessous.\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  mutate(mois_publication = months(date_sitePublicationDay, abbreviate = T)) %&gt;% \n  ggplot() + \n  aes(x = contractDuration_value, \n      y = fct_reorder(mois_publication, contractDuration_value, .fun=mean)) + \n  geom_boxplot(outlier.shape = NA) + \n  stat_summary(fun=mean, geom=\"point\", color=\"gray50\", size=2) +\n  coord_cartesian(xlim=c(0,550))  + \n  scale_x_continuous(breaks=seq(0,550,30))\nOn observe que les offres d’emploi avec des contrats légèrement plus longs sont plus probables au mois de septembre puis de novembre, alors qu’en début d’année civile (janvier et février) c’est là où les moyennes sont les plus basses. Cependant, comme ici notre seconde variable est une variable temporelle - le mois -, cela n’est pas forcément pertinent de modifier l’ordre du graphique pour le mettre selon la moyenne car cela pourrait perturber la lecture du graphique. On va revenir sur le graphique précédent donc.\nNous arrivons à un graphique intéressant, il faut maintenant améliorer la description autour : noms des axes, titres, légende informative sous le graphique (avec notamment un avertissement sur les valeurs non affichées sur le graphique), éventuellement un peu de couleur (avec fill= non pas dans l’aes() mais dans la fonction geom_boxplot() pour qu’elle soit identique quel que soit le département), etc.\nCela se fait avec la fonction labs(), et ensuite la fonction theme().\nUne petite astuce pour les titres pour qu’ils ne soient pas coupés sur le graphe : \\n collé à un mot (sans espace) permet de mettre à la ligne à partir de ce mot !\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  mutate(mois_publication = months(date_sitePublicationDay, abbreviate = T),\n         mois_publication = factor(mois_publication, \n                                   levels = c(\"déc.\",\"nov.\",\"oct.\",\"sept.\", \"août\", \"juil.\",\n                                              \"juin\",\"mai\",\"avr.\", \"mars\", \"févr.\", \"janv.\"))) %&gt;% \n  ggplot() + aes(x = contractDuration_value, y=mois_publication) + \n  geom_boxplot(outlier.shape = NA, fill=\"khaki\") + \n  stat_summary(fun=mean, geom=\"point\", color=\"gray50\", size=2) +\n  coord_cartesian(xlim=c(0,550))  + \n  scale_x_continuous(breaks=seq(0,550,30)) +\n  labs(title=\"Distribution de la durée des offres d'emploi en CDD et missions d'intérim dans Paris \\net sa petite couronne en 2020\", \n       x=\"Durée du contrat proposé en mois\", y=\"Mois\",\n       caption=\"Remarques : Les valeurs au-dessus de 550 jours soit 18 mois ne sont pas affichées ; les points \\nau-delà du minimum et maximum non plus ; les points en gris représentent la moyenne. \\nSource : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto.\") +\n  theme(plot.caption = element_text(hjust=0),\n        plot.title = element_text(size=12),\n        axis.title.x = element_text(size=10),\n        axis.title.y = element_text(size=10))\nVoilà un premier graphique construit avec la grammaire de ggplot(). À vous maintenant de construire vous-mêmes les graphiques qui vous sont suggérés dans la section suivante !",
    "crumbs": [
      "Séance 3",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Mining et Data Visualization en pratique</span>"
    ]
  },
  {
    "objectID": "08-Ggplot-pratique.html#dautres-exemples-à-travers-des-exercices",
    "href": "08-Ggplot-pratique.html#dautres-exemples-à-travers-des-exercices",
    "title": "8  Data Mining et Data Visualization en pratique",
    "section": "8.2 D’autres exemples à travers des exercices",
    "text": "8.2 D’autres exemples à travers des exercices\n\n8.2.1 Distribution de la durée des contrats proposés, selon le type de contrat\nConstruisez le même type de graphique mais cette fois à partir d’une densité de distribution selon le type de contrat - CDD ou intérim. N’hésitez pas à changer les options pour le mettre à votre goût !!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nOffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value)) %&gt;% \n  ggplot() + \n  aes(x = contractDuration_value, fill = contractType) + \n  geom_density(alpha = 0.4, color=NA) +\n  coord_cartesian(xlim=c(0,550)) + \n  scale_x_continuous(breaks=seq(0,550,30)) +\n  labs(title=\"Distribution de la durée des offres d'emploi en CDD et missions d'intérim dans Paris \\net sa petite couronne en 2020\", \n       x=\"Durée du contrat proposé en mois\", y=\"\", fill=\"Type de contrat\",\n       caption=\"Remarques : Les valeurs au-dessus de 550 jours soit 18 mois ne sont pas affichées. \\nSource : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto.\") +\n  theme(plot.caption = element_text(hjust=0),\n        plot.title = element_text(size=11),\n        axis.title.x = element_text(size=10),\n        axis.title.y = element_text(size=10))\n\n\n\n\n\n\n8.2.2 Comparaison des montants moyen et médian des durées de contrat des offres d’emplois, par secteur d’activité\nConstruisez maintenant un graphique mettant l’un à côté de l’autre deux graphes en bâtons représentant respectivement la durée moyenne et la durée médiane des offres d’emploi selon le secteur d’activité.\nPour vous aider si besoin, réfléchissez par étapes :\n\nil est bien de commencer par créer une variable en regroupant certains secteurs et en leur donnant un nom complet pour pouvoir plus facilement les identifier ;\ncréer un premier graphe que vous assignerez à un nouvel objet et qui représentera celui de la moyenne par secteur ;\nvous pouvez pour cela créer une nouvelle variable qui constituera la moyenne pour chaque secteur (un conseil : arrondir à l’unité) ;\nsélectionnez les variables qui seront utilisées dans le graphique et vérifier (ou corriger sinon) qu’il n’y ait pas des doublons (lignes identiques) car cela peut fausser le graphique ;\nconstruisez le graphique avec ggplot() et la bonne fonction geom_***() ;\nfaîtes de même pour la médiane par secteur ;\nvous pouvez ensuite mettre ces graphiques côte à côté avec le package patchwork (qu’il vous faudra probablement installer si c’est la première fois que vous l’utilisez), recherchez sur internet comment faire ensuite (c’est très simple !), puis mettez le même axe des ordonnées pour gagner de la place avec l’argument plot_layout(axes = \"collect\"), enfin ajoutez un titre et une légende générale avec la fonction plot_annotation().\n\n\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;% \n  mutate(mois_publication=months(date_sitePublicationDay, abbreviate = T),\n         secteurs=as.factor(case_when(entrepriseSecteur_NAF21 %in% c(\"C\", \"D\", \"E\") ~ \"Industrie\",\n                                      entrepriseSecteur_NAF21 ==\"F\" ~ \"Construction\",\n                                      entrepriseSecteur_NAF21 ==\"G\" ~ \"Commerce\",\n                                      entrepriseSecteur_NAF21 ==\"H\" ~ \"Transports\",\n                                      entrepriseSecteur_NAF21 ==\"I\" ~ \"Hébergement/restauration\",\n                                      entrepriseSecteur_NAF21 ==\"J\" ~ \"Info/com\",\n                                      entrepriseSecteur_NAF21 %in% c(\"K\", \"L\") ~ \"Activités financières et immo\",\n                                      entrepriseSecteur_NAF21 ==\"M\" ~ \"Activités spécialisées, scientifiques et techniques\",\n                                      entrepriseSecteur_NAF21 ==\"N\" ~ \"Activités de services administratifs et de soutien\",\n                                      entrepriseSecteur_NAF21 ==\"O\" ~ \"Administration publique\",\n                                      entrepriseSecteur_NAF21 ==\"P\" ~ \"Enseignement\",\n                                      entrepriseSecteur_NAF21 ==\"Q\" ~ \"Santé humaine et action sociale\",\n                                      entrepriseSecteur_NAF21 ==\"R\" ~ \"Arts, spectacles et activités récréatives\",\n                                      entrepriseSecteur_NAF21 ==\"S\" ~ \"Autres activités de service\",\n                                      entrepriseSecteur_NAF21 ==\"T\" ~ \"Activités des ménages en tant qu'employeurs\",\n                                      TRUE ~ entrepriseSecteur_NAF21)))\n\n# On va supprimer les 7 offres qui sont dans le secteur \"U\" \"Activités extra-territoriales\"...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\np1 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           !entrepriseSecteur_NAF21==\"U\") %&gt;% \n  group_by(secteurs) %&gt;% \n  mutate(moy_duree = round(mean(contractDuration_value))) %&gt;% \n  select(moy_duree, secteurs) %&gt;% \n  unique()  %&gt;% \n  ggplot() + aes(x = moy_duree, y = secteurs) +\n  geom_bar(stat=\"identity\", fill=\"honeydew\") +\n  geom_text(aes(label = moy_duree), position = position_stack(vjust = 0.5), color=\"gray25\", size=2.8) + \n  scale_x_continuous(breaks=seq(0,275,30)) +\n  labs(title = \"Moyenne\", x = \" \", y = \" \") +\n  theme(axis.text.x = element_text(angle=90, vjust=0.5, size=8.5),\n        plot.title = element_text(size=10.5))\n\n\np2 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           !entrepriseSecteur_NAF21==\"U\") %&gt;% \n  group_by(secteurs) %&gt;% \n  mutate(mediane_duree = round(median(contractDuration_value))) %&gt;% \n  select(mediane_duree, secteurs) %&gt;% \n  unique() %&gt;% \n  ggplot() + aes(x = mediane_duree, y = secteurs) +\n  geom_bar(stat=\"identity\", fill=\"honeydew\") + \n  geom_text(aes(label = mediane_duree), position = position_stack(vjust = 0.5), color=\"gray25\", size=2.8) +\n  scale_x_continuous(breaks=seq(0,275,30)) +\n  labs(title = \"Médiane\", x = \" \", y = \" \") +\n  theme(axis.text.x = element_text(angle=90, vjust=0.5, size=8.5),\n        plot.title = element_text(size=10.5))\n\nlibrary(patchwork)\n(p1 + p2) + plot_layout(axes = \"collect\") +\nplot_annotation(title = \"Durée (en mois) des CDD et intérim dans les offres d'emploi sur Paris et sa petite couronne, \\nen 2020 et selon le secteur d'activité\",\n                caption = \"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto.\", \n                theme = theme(plot.title = element_text(size = 12),\n                              plot.caption = element_text(hjust = 0)))\n\n\n\n\nOn observe que ce sont deux secteurs regroupant des activités publiques - administration et enseignement - qui proposent des contrats avec des durées (moyennes et médianes) relativement plus longues, ce qui peut être logique puisque le droit sur la durée des contrats à durée déterminée est justement différent. A l’inverse, deux secteurs des services - “Activités spécialisées, scientifiques et techniques”, et “Activités de services administratifs et de soutien” - présentent des durées moyennes et médianes relativement courtes ; on retrouve ensuite l’hébergement/restauration et la construction pour les moyennes, car les médianes sont toutes identiques au-delà des 4 premiers secteurs cités.\nOn aurait pu sinon utilser un “dot plot”, comme ci-dessous. Cherchez comment l’on peut construire ce type de graphique (rq : cela ne correspond par à une fonction en tant que telle). Le début du code est le même, ce sont les fonctions geom_*** qui changent…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\nlibrary(\"ggrepel\")\np3 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           !entrepriseSecteur_NAF21==\"U\") %&gt;% \n  group_by(secteurs) %&gt;% \n  mutate(moy_duree = round(mean(contractDuration_value))) %&gt;% \n  select(moy_duree, secteurs) %&gt;% \n  unique()  %&gt;% \n  ggplot() + aes(x =moy_duree , y = secteurs) +\n  geom_point(color=\"burlywood4\", size=2) + \n  geom_segment(aes(x=0, xend=moy_duree, y=secteurs), color=\"snow4\") +\n  geom_text_repel(aes(label = moy_duree), size = 2.5) + \n  labs(title = \"Moyenne\", x = \" \", y = \" \") +\n  theme(plot.title = element_text(size=10.5))\n\n\np4 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           !entrepriseSecteur_NAF21==\"U\") %&gt;% \n  group_by(secteurs) %&gt;% \n  mutate(mediane_duree = round(median(contractDuration_value))) %&gt;% \n  select(mediane_duree, secteurs) %&gt;% \n  unique()  %&gt;% \n  ggplot() + aes(x =mediane_duree , y = secteurs) +\n  geom_point(color=\"burlywood4\", size=2) + \n  geom_segment(aes(x=0, xend=mediane_duree, y=secteurs), color=\"snow4\") +\n  geom_text_repel(aes(label = mediane_duree), size = 2.5) + \n  labs(title = \"Médiane\", x = \" \", y = \" \") +\n  theme(plot.title = element_text(size=10.5))\n \n(p3 + p4) + plot_layout(axes = \"collect\") +\nplot_annotation(title = \"Moyennes et médianes de la durée des contrats des offres d'emploi en CDD et intérim sur Paris et \\nsa petite couronne, en 2020 et selon le secteur d'activité\", \n                caption = \"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto.\", \n                theme = theme(plot.title = element_text(size = 12),\n                              plot.caption = element_text(hjust = 0)))\n\n\n\n\n\n\n8.2.3 Evolution de la durée des contrats des offres d’emploi durant l’année 2020\nChangeons un peu de perspective et construisez cette fois un graphique montrant l’évolution de la durée des contrats des offres d’emploi durant l’année 2020 à Paris et sa petite couronne, de manière générale et ensuite selon 6 secteurs choisis selon leur durée médiane mise en avant un peu plus haut : les 3 ayant les durées moyennes les plus élevées (“Administration publique”, “Enseignement”, et “Arts, spectacles et activités récréatives”), et les 3 ayant les durées moyennes les moins élevées (“Activités spécialisées, scientifiques et techniques”, “Activités de services administratifs et de soutien”, et “Hébergement/restauration”).\nOn peut vouloir le rendre interactif de telle sorte que l’utilisateur puisse voir les valeurs des points en passant la souris dessus : pour cela, il faut installer et charge le package plotly puis utiliserla fonction ggplotly() ; cela nécessite de stocker le graphique dans un objet.\nDe même, il faut procéder par étapes :\n\ncréer la variable de prix moyen de durée selon le mois ;\nne garder que ces variables, supprimer les lignes doublons le cas échéant ;\nconstruir un graphique sous forme de courbes avec des points représentants les valeurs en le stockant dans un objet ;\nappeler la fonction ggplotly() en utilisant l’argument tooltip() pour que seule la valeur des “y” soit affichée..\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\ng_evo &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           !entrepriseSecteur_NAF21==\"U\") %&gt;% \n  group_by(mois_publication) %&gt;% \n  mutate(moy_duree = round(mean(contractDuration_value)),\n         mois_publication = factor(mois_publication, \n                                   levels = c(\"janv.\",\"févr.\",\"mars\",\"avr.\",\"mai\",\"juin\",\n                                              \"juil.\",\"août\",\"sept.\",\"oct.\",\"nov.\",\"déc.\"))) %&gt;% \n  select(moy_duree, mois_publication) %&gt;% \n  unique()  %&gt;% \n  ggplot() + aes(x = mois_publication, y = moy_duree) +\n  geom_point() + geom_line(group=1)  +\n  scale_y_continuous(limits=c(90,180), breaks = seq(90,180,15)) +\n  labs(title = \"Evolution de la durée moyenne des contrats dans les offres d'emplois en CDD et intérim sur \\nParis et sa petite couronne en 2020\", \n       x = \" \", y = \" \") +\n  theme(plot.title = element_text(size=12), \n        plot.caption = element_text(hjust=0))\n\n#install.packages(\"plotly\")\nlibrary(plotly)\nggplotly(g_evo, tooltip = c(\"moy_duree\")) %&gt;% \n layout(margin = list(l = 50, r = 50, b = 80, t = 50),\n        annotations = list(text = \"Source : Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto. \\nNote : l'axe des ordonnées ne commence qu'à 90 jours (3 mois).\",\n                           showarrow = F, x = 0, y = -0.2, \n                           xref='paper', yref='paper', xanchor='left', yanchor='auto',  \n                           xshift=0, yshift=0, font=list(size=10.5), align=\"left\"))\n\n\n\n\nOn retrouve un résultat que l’on avait observé précédemment avec la boxplot, à savoir que la durée moyenne des contrats est plus faible en début d’année civiel et connaît deux “pics”, en septembre puis en novembre.\nRegardons maintenant selon quelques secteurs d’activité (les 6 mentionnés au-dessus), pour étudier si cette évolution est différente selon la position du secteur dans l’échelle des durées moyennes.\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\ng_evo_pls &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           secteurs %in% c(\"Administration publique\", \"Enseignement\", \n                         \"Arts, spectacles et activités récréatives\",\n                         \"Hébergement/restauration\", \n                         \"Activités spécialisées, scientifiques et techniques\",\n                         \"Activités de services administratifs et de soutien\")) %&gt;% \n  group_by(mois_publication, secteurs) %&gt;% \n  mutate(moy_duree = round(mean(contractDuration_value),0),\n         mois_publication = factor(mois_publication, \n                                   levels = c(\"janv.\",\"févr.\",\"mars\",\"avr.\",\"mai\",\"juin\",\n                                              \"juil.\",\"août\",\"sept.\",\"oct.\",\"nov.\",\"déc.\"))) %&gt;% \n  select(moy_duree, mois_publication, secteurs) %&gt;% \n  unique() %&gt;% \n  mutate(secteurs=factor(secteurs, \n                          levels = c(\"Administration publique\", \"Enseignement\", \n                         \"Arts, spectacles et activités récréatives\", \n                         \"Activités spécialisées, scientifiques et techniques\",\n                         \"Activités de services administratifs et de soutien\",\n                         \"Hébergement/restauration\"))) %&gt;% \n  ggplot() + aes(x=mois_publication, y=moy_duree, color=secteurs) + \n  geom_line(aes(group=secteurs), linewidth=0.8) +\n  scale_y_continuous(limits=c(75,425), breaks = seq(75,425,15)) +\n  labs(title=\"Evolution de la durée moyenne des contrats dans les offres d'emplois en CDD et missions d'intérim sur Paris \\net sa petite couronne en 2020, dans les trois secteurs ayant les moyennes les plus élevées et les 3 secteurs \\nayant les moyennes les plus faibles\", x = \" \", y = \" \", color=\"Secteurs\") +\n  theme(plot.title = element_text(size=10), \n        legend.title = element_text(size=10),\n        plot.caption = element_text(hjust=0))\n\nggplotly(g_evo_pls, tooltip = c(\"moy_duree\")) %&gt;% \n layout(margin = list(l = 50, r = 50, b = 80, t = 80),\n        annotations = list(text = \"Source : Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto. \\nNote : l'axe des ordonnées ne commence qu'à 75 jours (2 mois et demi).\",\n                           showarrow = F, x = 0, y = -0.2, \n                           xref='paper', yref='paper', xanchor='left', yanchor='auto',  \n                           xshift=0, yshift=0, font=list(size=9), align=\"left\"))\n\n\n\n\nOn observe une saisonnalité beaucoup plus importante dans la durée des contrats proposés selon les secteurs, la volatilité la plus grande de la durée moyenne des contrats est présente dans le secteur des “arts, spectacles et activités récréatives”. Cela peut être dû en partie à cette année 2020, particulière du fait de la crise sanitaire du Covid-19. Il faudrait bien sûr creuser davantage pour mieux comprendre ces évolutions de la durée moyenne des contrats proposés selon les secteurs d’activité et les mois.\n\n\n8.2.4 Top 5 de la durée moyenne des offres d’emploi en CDD et missions d’intérim selon les secteurs d’activité\nEnfin, construisez un graphique en bâtons indiquant les seuls 5 premiers secteurs d’activité ayant les durées moyennes des offres d’emploi en CDD et missions d’intérim les plus élevés, puis les durées médianes, et les mettre côte à côte.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipSolution\n\n\n\n\n\n\np5 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           secteurs %in% c(\"Administration publique\", \"Enseignement\", \n                         \"Arts, spectacles et activités récréatives\",\n                         \"Hébergement/restauration\", \n                         \"Activités spécialisées, scientifiques et techniques\",\n                         \"Activités de services administratifs et de soutien\")) %&gt;% \n  group_by(secteurs) %&gt;% \n  summarise(moy_duree = round(mean(contractDuration_value))) %&gt;% \n  arrange(desc(moy_duree)) %&gt;% slice(1:5) %&gt;% \n  ggplot() + aes(x = moy_duree, y = fct_reorder(secteurs, moy_duree))  + \n  geom_bar(stat=\"identity\", fill=\"darkgoldenrod1\")  +\n  geom_text(aes(label=moy_duree), position = position_stack(vjust=0.5), size=2.5) +\n  labs(title=\"Durée moyenne en jours\",\n       x = \"\", y = \" \") +\n  theme_classic() +\n  theme(legend.position = \"none\", plot.title=element_text(size=9),\n        axis.text.y = element_text(size=8),\n        axis.text.x = element_text(size=8),\n        axis.title.x = element_text(size=8))\n\np6 &lt;- OffresPE_2020 %&gt;% \n  filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n           secteurs %in% c(\"Administration publique\", \"Enseignement\", \n                         \"Arts, spectacles et activités récréatives\",\n                         \"Hébergement/restauration\", \n                         \"Activités spécialisées, scientifiques et techniques\",\n                         \"Activités de services administratifs et de soutien\")) %&gt;% \n  group_by(secteurs) %&gt;% \n  summarise(mediane_duree = round(median(contractDuration_value)),\n            moy_duree = round(mean(contractDuration_value))) %&gt;% \n  arrange(desc(mediane_duree)) %&gt;% slice(1:5) %&gt;% \n  ggplot() + aes(x = mediane_duree, y = fct_reorder(secteurs, moy_duree))  + \n  geom_bar(stat=\"identity\", fill=\"coral1\")  +\n  geom_text(aes(label=mediane_duree), position = position_stack(vjust=0.5), size=2.5) +\n  labs(title=\"Durée médiane en jours\",\n       x = \"\", y = \" \") +\n  theme_classic() +\n  theme(legend.position = \"none\", plot.title=element_text(size=9),\n        axis.text.y = element_text(size=8),\n        axis.text.x = element_text(size=8),\n        axis.title.x = element_text(size=8))\n\n(p5 + p6) + plot_layout(axes = \"collect\") +\n  plot_annotation(title =  \"Top 5 des secteurs d'activité ayant des offres d'emploi en CDD et missions d'intérim \\navec les durées moyennes les plus élevées\", \n                caption = \"Source : Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020. \\nCalculs : Camille Signoretto.\", \n                theme = theme(plot.title = element_text(size = 12))) &\n  theme(plot.caption = element_text(hjust = 0))\n\n\n\n\nOn retrouve les mêmes résultats.\n\n\n8.2.5 À vous de “jouer” !\nBien sûr, vous pouvez créer des fonctions sur ces graphiques ; puis “jouez” avec d’autres variables ; ou encore construire des cartes sur le niveau commune ; utiliser d’autres types de graphiques ; etc. ; etc.",
    "crumbs": [
      "Séance 3",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Mining et Data Visualization en pratique</span>"
    ]
  },
  {
    "objectID": "09-Intro-a-Shiny-theorique.html",
    "href": "09-Intro-a-Shiny-theorique.html",
    "title": "9  Les applications interactives avec Shiny App",
    "section": "",
    "text": "9.1 La structure générale d’une application Shiny\nComme indiqué sur la page officielle de Shiny-RStudio ici, Shiny est un package R qui permet de créer des applications ou des pages web de visualisations interactives de données, directement à partir de R, autremet dit sans connaître nécessairement le langage HTML, Javascript, etc., et donc aussi en pouvant utiliser toutes les fonctions disponibles sous R. En réalité, l’interface utilisateur de l’application Shiny est bien du langage HTML, mais Shiny donne des outils faciles pour l’écrire sans avoir à connaître le HTML.\nIl nous faut d’abord installer le package Shiny, puis le charger :\nDes exemples d’application Shiny sont données sur la page officielle dans la galerie ; ou on peut aussi en lancer une directement dans R, avec par exemple le code suivant :\nUn autre exemple d’application finale qui comprend un aspect territorial donc avec de jolis cartes, et qui s’appuie sur les données du Recensement de la population (rassemblées par l’Insee sur la période 1968-2019 et qui forme la base Saphir), est disponible ici .\nEnfin, cette introduction s’appuie sur d’autres ressources externes, pour n’en citer que quelques uns : - un bon tutoriel ici ; - une introduction claire là. Et vous trouverez sur les 2 liens suivants deux ouvrages en ligne, pour compléter et aller plus loin : the Mastering Shiny ; et the Interactive web-based data visualization with R, plotly, and shiny.\nL’application est divisée en 2 sections : l’interface utilisateur (ui) et une fonction serveur (server). L’intérêt de Shiny est sa réactivité : quand l’utilisateur change un paramètre, tout ce qui dépend de ce paramètre est automatiquement actualisé sur la page. On dit que c’est une application “server-based”, dans la mesure où la construction des graphiques et/ou tableaux affichés (ou tout autre objet) se font sur le serveur, autrement dit sur le RStudio de votre ordinateur.\nAinsi, comme on peut le voir sur les exemples cités au-dessus, la structure du code sera toujours la suivante :\nlibrary(shiny)\n\n# Fonction \"ui\"\nui &lt;- fluidPage(\n                )\n\n# Fonction \"server\"\nserver &lt;- function(input, output) {\n  \n                   }\n\n# Fonction qui crée l'application Shiny en reprenant les 2 fonctions \n# principales. A noter que comme elles ont le même nom, souvent on ne \n# précisera pas de nouveau les arguments \"ui = \" et \"server = \"\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les applications interactives avec Shiny App</span>"
    ]
  },
  {
    "objectID": "09-Intro-a-Shiny-theorique.html#la-structure-générale-dune-application-shiny",
    "href": "09-Intro-a-Shiny-theorique.html#la-structure-générale-dune-application-shiny",
    "title": "9  Les applications interactives avec Shiny App",
    "section": "",
    "text": "9.1.1 La partie “UI”\nL’UI ou “interface utilisateur” utilise par défaut la fonction fluidPage() qui permet de créer la mise en page de l’application et qui répondra automatiquement aux changements effectués sur le navigateur par l’utilisateur.\nCette fonction fluidPage() va contenir des indications comme le titre (avec titlePanel()), éventuellement un sous-titre, etc., ainsi que deux fonctions sidebarLayout() et mainPanel().\nLe première comprend la fonction sidebarPanel() qui contient le ou les “widgets” à partir duquel ou desquels les utilisateurs sélectionneront des valeurs – par défaut est indiqué un sliderInput(). La seconde contient la sortie voulue, c’est-à-dire un graphique, un tableau, etc., avec par défaut la fonction plotOutput(), mais elle peut en contenir d’autres… Les graphiques ou tableaux de ces fonctions ...Ouput() sont ensuite précisées (et construits) dans la partie “Server” de l’application Shiny.\n\n#library(shiny)\n\n# Fonction \"ui\"\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Titre à définir\"),\n  \n  # Mise en page de la barre latérale avec les définitions des \n  # entrées et des sorties\n  sidebarLayout(\n    \n    # Panneau latéral pour les entrées\n    sidebarPanel(\n      \n      # Entrée : wigdet choisi, par défaut \"sliderInput()\"\n      sliderInput(\n        \n      )\n      \n    ),\n    # Panneau principal pour l'affichage des sorties\n    mainPanel(\n      # Sortie : graphique, tableau, etc.\n      plotOutput(\"nom_du_graphe\")\n      )\n    )\n  )\n\n# Fonction \"server\"\nserver &lt;- function(input, output) {\n  \n                   }\n\n# Fonction qui crée l'application Shiny\nshinyApp(ui = ui, server = server)\n\nLa liste des widgets est reproduite ci-dessous avec un tableau et une image récapitulative (disponible directement ici) ; à part les arguments communs inputID() et label(), les autres arguments diffèrent selon le widget, il est donc essentiel d’y faire un tour avant d’en utiliser un si l’on ne le connaît pas a priori.\n\nTableau : Fonctions Shiny et widgets associés\n\n\n\n\n\n\nFonction\nWidget\n\n\n\n\nsliderInput\nBarre de défilement\n\n\nactionButton\nBouton d’action\n\n\ncheckboxGroupInput\nGroupe de cases à cocher\n\n\ncheckboxInput\nCase unique à cocher\n\n\ndateInput\ncalendrier pour sélectionner une ou des dates\n\n\ndateRangeInput\nPaire de calendriers pour sélectionner une plage de dates\n\n\nnumericInput\nChamp pour saisir des chiffres\n\n\nradioButtons\nSérie de boutons radio\n\n\nselectInput\nBoîte avec des choix à sélectionner\n\n\nsubmitButton\nBouton de validation\n\n\nfileInput\nCommande pour télécharger un fichier à partir d’un chemin\n\n\ntextInput\nChamp pour saisir du texte\n\n\nhelpText\nTexte d’aide qui peut être ajouté à un formulaire de saisie\n\n\n\nWidgets de l’application Shiny\n\nD’autres interfaces utilisateur existent. Par exemple, avec le package bslib, on peut utiliser la fonction page_sidebar() à la place de fluidPage(), comme ceci :\n\n#library(shiny)\nlibrary(bslib)\n\n# Fonction \"ui\"\nui &lt;- page_sidebar(\n  \n  title = \"Titre à définir\",\n  \n  sidebar = sidebar(\"Barre latéral\"),\n  \n  \"Contenu principal\",\n\n  mainPanel(\n      # Sortie : graphique, tableau, etc.\n      plotOutput(\"nom_du_graphe\")\n      )\n)\n\n# Fonction \"server\"\nserver &lt;- function(input, output) {\n  \n                   }\n\n# Fonction qui crée l'application Shiny\nshinyApp(ui = ui, server = server)\n\nOu encore la fonction navbarPage() pour permettre plusieurs onglets de navigation sur la même page web (que l’on créera avec la fonction tabPanel() à l’intérieur de laquelle on retrouvera les fonctions sidebarPanel() et mainPanel()) :\n\n# Fonction \"server\"\nui &lt;- navbarPage(\n\n  title=\"Titre à définir\",\n  \n  tabPanel(title = \"Graphique\",\n           fluidPage(\n             sidebarLayout(\n               sidebarPanel(\n                 # sliderInput(\n                 #    )\n                 ),\n               mainPanel(\n                 plotOutput(\"nom_du_graphe\")\n                 )             \n               )\n           )\n           ),\n  \n  tabPanel(\"Résumé des variables\"),\n  \n  tabPanel(\"Tableau\"),\n   \n    )\n\n# Fonction \"server\"\nserver &lt;- function(input, output) {\n  \n                   }\n\n# Fonction qui crée l'application Shiny\nshinyApp(ui = ui, server = server)\n\n\n\n9.1.2 La partie “Server”\nC’est la fonction Server qui contient le code principal faisant tourner l’application web.\nElle est définie par la fonction function(input, output){ }. À chaque fonction ...Ouput() dans l’ui correspond une fonction render...() dans la partie Server. Par exemple, si dans la partie ui, on a définit un histogramme comme ceci dans la fonction : plotOuput(\"distPlot\"), alors dans la partie server, on associera la fonction renderPlot() à output$distPlot. Les fonctions render...() sont celles qui contiennent en effet le code créant, l’histogramme ici, ou tout autre graphique ou tableau, l’ensemble de l’expression à l’intérieur de cette fonction sera contenu dans des accolades {}.\n\n#library(shiny)\n\n# Fonction \"ui\"\nui &lt;- fluidPage(\n    # Titre de l'application\n  titlePanel(\"Titre à définir\"),\n  \n  # Mise en page de la barre latérale avec les définitions des \n  # entrées et des sorties\n  sidebarLayout(\n    \n    # Panneau latéral pour les entrées\n    sidebarPanel(\n      \n      # Entrée : wigdet choisi, par défaut \"sliderInput()\"\n      sliderInput(\n        \n      )\n      \n      ),\n    \n    # Panneau principal pour l'affichage des sorties\n    mainPanel(\n      # Sortie : graphique, tableau, etc.\n      plotOutput(\"nom_du_graphe\")\n      )\n    \n    )\n  \n  )\n\n# Fonction \"server\"\nserver &lt;- function(input, output) {\n  \n  # Reprend la sortie mentionnée plus haut (ici \"nom_du_graphe\")\n  output$nom_du_graphe &lt;- renderPlot({\n    \n    # code de création du graphique, qui sera réactive selon les \n    # valeurs données en entrées (cf. fonction \"fluidPage()\")\n    \n  })\n                   }\n\n# Fonction qui crée l'application Shiny\nshinyApp(ui = ui, server = server)\n\nVoici les différentes fonctions ...Ouput() créant un objet de sortie :\n\n\n\nFonction de sortie\nType d’objet créé\n\n\n\n\ndataTableOutput\nTable de données\n\n\nimageOutput\nImage\n\n\nplotOutput\nGraphique\n\n\ntableOutput\nTable\n\n\ntextOutput\nTexte\n\n\nuiOutput\nHTML brut\n\n\nhtmlOutput\nHTML brut\n\n\nverbatimTextOutput\nTexte\n\n\n\nEt les fonctions render...() associées :\n\n\n\n\n\n\n\nFonction de sortie\nType d’objet créé\n\n\n\n\nrenderDataTable\nTable de données\n\n\nrenderImage\nImage (enregistré comme un lien vers un fichier source)\n\n\nrenderPlot\nGraphique\n\n\nrenderTable\nTable de données, matrices, ou autres structures de type tableau\n\n\nrenderText\nTexte sous forme de chaînes de caractères\n\n\nrenderUI\nobjet de balise Shiny ou HTML\n\n\nrenderPrint\nToute sortie imprimée",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les applications interactives avec Shiny App</span>"
    ]
  },
  {
    "objectID": "09-Intro-a-Shiny-theorique.html#la-réactivité",
    "href": "09-Intro-a-Shiny-theorique.html#la-réactivité",
    "title": "9  Les applications interactives avec Shiny App",
    "section": "9.2 La réactivité",
    "text": "9.2 La réactivité\nComme dit précédemment, la réactivité est au centre du fonctionnement d’une application Shiny. Plusieurs types de réactivité peut être distingués :\n\nun premier type de réactivité, le plus simple, à travers les interactions entre les fonctions ui() et server() : comme expliqué au-dessus, cela passe par les “input” définis dans la partie ui et les “output” créés dans la partie server ; plus précisément, si on a définit un widget permettant par exemple de choisir une année donnée et qu’on l’a appelé annee (avec l’argument id=\" \"), alors dans la ou les fonctions render...() de la partie server, il faudra renvoyer à cette variable par l’indication input$annee. De manière générale, il faudra accoler le nom donné à un input x de cette façon dans le server : input$x.\nCela peut être résumé par le schéma suivant, emprunté à l’une des sources citées en introduction :\n\n\nSource : https://laderast.github.io/gradual_shiny/introduction.html\n\nun deuxième type de réactivité à travers la base de données elle-même, c’est-à-dire qui crée un objet réactif (qui sera à la fois une entrée réactive et une sortie réactive) : il faut alors utiliser, par exemple, la fonction reactive({}) (ou son corrolaire eventReactive()) en l’appliquant à la base de données initiale et en renvoyant ainsi une nouvelle base, qui sera elle-même une fonction. On peut par exemple appliquer un filtre à notre base de données selon l’année : au lieu alors de préciser input$annee dans la fonction render...() comme mentionné dans le premier type de réactivité, on va en réalité créer une nouvelle base comme ceci : data_reactive &lt;- reactive({ data %&gt;% filter(annee &gt; input$annee)) }) ; puis l’appeler ainsi pour créer le graphique : output$nom_du_graphe &lt;- renderPlot({ data_reactive() }), attention vous noterez l’utilisation des parenthèses après le nouveau nom de la table. De même, cela peut être résumé par le schéma suivant tiré de la même source :\n\n\nSource : https://laderast.github.io/gradual_shiny/app-2-reactives.html\n\nun troisième type de réactivité qui crée un contexte réactif, à travers notamment la fonction observe({}) (ou son corrolaire observeEvent()) : cette fonction sera utilisée losque vous souhaitez faire une opération qui dépend de plusieurs autres variables réactives, en particulier si vous souhaitez changer un input qui est dépendant d’un autre input, mais sans créer nécessairement d’output. Cela peut être utile si le choix d’une variable - les départements d’une région par exemple - est conditionnée au choix antérieur de la région en question : dans ce cas, l’utilisateur qui choisira une région dans un premier widget ne verra s’afficher que les départements de cette région dans un second widget et non tous les départements disponibles dans la base de données.\n\nIl y a bien d’autres fonctions de réactivité dans Shiny : eventReactive(), observeEvent(), reactiveValues(), isolate(), req(), mais qu’on ne présentera pas forcément en détails dans ce cours mais que vous pourrez utiliser dans votre application finale.",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les applications interactives avec Shiny App</span>"
    ]
  },
  {
    "objectID": "09-Intro-a-Shiny-theorique.html#un-exemple-avec-le-code-du-script-par-défaut",
    "href": "09-Intro-a-Shiny-theorique.html#un-exemple-avec-le-code-du-script-par-défaut",
    "title": "9  Les applications interactives avec Shiny App",
    "section": "9.3 Un exemple avec le code du script par défaut",
    "text": "9.3 Un exemple avec le code du script par défaut\nVoyons ensemble un premier exemple : dans RStudio, ouvrez un nouveau fichier “Shiny Web App…” que vous intitulez comme vous le souhaitez (attention, pas d’espace permis entre deux mots par exemple), vous laissez l’option “Single File” et vous l’enregistrez de préférence dans votre projet.\nUn nouveau scrip s’ouvre avec par défaut un code minimal déjà écrit : on retrouve la structure du code présentée juste au-dessus, et à l’intérieur de l’UI et du Server quelques codes pour avoir un titre, un widget sous forme de “slider” et un graphique qui sera un histogramme d’après la fonction écrit dans la partie Server. Faisons tourner l’application avec le bouton en haut à droite “Run App” pour voir ce que cela donne ! On voit bien les différents éléments correspondants au code écrit dans le script R et on voit bien également que l’application est interactive puisque si l’on modifie le nombre de classes dans la barre slider, le graphique est modifié alors simultanément !",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les applications interactives avec Shiny App</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html",
    "href": "10-Intro-a-Shiny-exemples.html",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "",
    "text": "10.1 Application vide\nOn va de nouveau utiliser la base du RP sur laquelle nous travaillons depuis le début, mais en créant des tableaux de contingence à partir des fonctions sauvegardées dans la section précédente.\nFaisons tourner une application vide et ajoutons au fur et à mesure les éléments qui permettrons de construire une vraie application :\nlibrary(shiny)\n\nui &lt;- fluidPage(\n                )\n\nserver &lt;- function(input, \n                   output) {\n  \n                   }\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#ajout-dun-titre-et-dun-widget",
    "href": "10-Intro-a-Shiny-exemples.html#ajout-dun-titre-et-dun-widget",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "10.2 Ajout d’un titre et d’un widget",
    "text": "10.2 Ajout d’un titre et d’un widget\nAjoutons un titre et un widget, par exemple une barre “slider” :\n\n#library(shiny)\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"Classes\",\n                  label = \"Choix du nombre de classes : \",\n                  min = 1,\n                  max = 50,\n                  value = 25)\n      ),\n    \n  mainPanel(\n    plotOutput(\"histPlot\")\n    \n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  \n}\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#ajout-dun-graphique",
    "href": "10-Intro-a-Shiny-exemples.html#ajout-dun-graphique",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "10.3 Ajout d’un graphique",
    "text": "10.3 Ajout d’un graphique\nAjoutons un graphique ; il faut pour cela charger la base de données sur laquelle nous allons travailler ; pour l’exemple ici, nous allons créer un tableau de contingence à partir des fonctions créées précédemment (qu’on appelle donc avant) et donnant le nombre de propriétaires par commune de l’Île-de-France, en considérant les arrondissements de Paris comme des communes :\n\n# appel fonctions enregistrées\nsource(\"fonctions/fonctions.R\")\n\n# création de la table de données\ntab_proprio_com &lt;- RP_final %&gt;% filter(STOCD == \"10\") %&gt;% \n                                      somme(var_gpe=COM, nom_var=STOCD) %&gt;% \n                                      rename(nb_proprio = '10') %&gt;% \n                                      filter(COM!=\"ZZZZZ\")\n\n\n#library(shiny)\n\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(inputId = \"classes\",\n                        label = \"Choix du nombre de classes :\",\n                        min = 1,\n                        max = 50,\n                        value = 25)\n        ),\n\n        # Graphe montré à l'utilisateur\n        mainPanel(\n           plotOutput(\"histPlot\")\n        )\n  )\n)\n\nserver &lt;- function(input, output) {\n  \noutput$histPlot &lt;- renderPlot({\n  tab_proprio_com %&gt;%  \n    ggplot() + aes(x=nb_proprio) + geom_histogram(bins=25)\n})\n\n  }\n\nshinyApp(ui = ui, server = server)\n\nOn a bien maintenant le graphique qui s’affiche mais lorsqu’on change le nombre de classes dans la barre slider, rien ne se passe… C’est normal, nous n’avons pas encore introduit de réactivité dans l’application.\nPour cela, il va falloir modifier le code dans la fonction server et ainsi mettre en lien des informations indiquées dans la fonction UI avec les arguments utilisés dans le graphique développé dans la fonction server. Pour l’instant, on veut pouvoir modifier le nombre de classes, l’argument pour cela dans la fonction geom_histogram() dans le ggplot() est bins= ; on a indiqué ‘50’ jusqu’ici ; maintenant il faut lui indiquer le nombre que l’utilisateur va lui-même indiquer dans la barre slider ; cela se fait avec l’argument input$..., les “…” devant être remplacés par le nom que l’on a donné à l’inputId dans le sliderInput(), donc ici “classes”.\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes :\",\n                  min = 1,\n                  max = 50,\n                  value = 25)\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_proprio_com %&gt;%  \n        ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nÇa y est, maintenant lorsqu’on modifie le curseur dans la barre slider, le graphique change !",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#modification-du-graphique-filtrer-selon-une-variable",
    "href": "10-Intro-a-Shiny-exemples.html#modification-du-graphique-filtrer-selon-une-variable",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "10.4 Modification du graphique : filtrer selon une variable",
    "text": "10.4 Modification du graphique : filtrer selon une variable\nEssayons ensuite d’ajouter un filtre sur le département pour n’avoir que la distribution du nombre de propriétaires pour un département donné. Comme on n’a pas de variable de département, il faut la créer, ce que l’on peut faire assez facilement à partir des deux premiers chiffres de la commune, et ensuite il suffit d’ajouter un filtre sur cette nouvelle variable créée.\nDe même, on peut procéder par étapes : présentons d’abord le graphique pour le seul département de l’Île-de-France (75).\n\n# Création de la variable et donc remplacement de la table de données\ntab_proprio_com &lt;- tab_proprio_com %&gt;%\n  mutate(DEPT=as.factor(substr(COM, 1,2)))\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes :\",\n                  min = 1,\n                  max = 50,\n                  value = 25)\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_proprio_com %&gt;%  \n        filter(DEPT == \"75\") %&gt;% \n        ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nEnsuite, donnons la possibilité à l’utilisateur de choisir le département qu’il veut : il faut pour cela ajouter un widget dans la fonction UI ; comme on ne veut laisser qu’un choix de département à l’utilisateur, on peut utiliser un “Radio buttons” ; on regarde alors quels sont les arguments de la fonction radioButtons(), on voit qu’il faut indiquer les choix possibles donc ici la liste des départements dans choices = et indiquer une valeur par défaut dans selected = ; pour cela, on peut indiquer la variable correspondante choices = tab_proprio$DEPT, mais attention si on laisse comme ceci, on va avoir une répétition de noms des départements comme lorsqu’on ouvre la table, ce qu’on veut c’est uniquement les niveaux… deux possibilités alors : soit créer avant l’appel de la fonction UI une variable avec simplement les niveaux de cette variable ; soit passer par la fonction unique() dans l’argument donné.\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes :\",\n                  min = 1,\n                  max = 50,\n                  value = 25),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département :\",\n                   choices = levels(tab_proprio_com$DEPT), #ou indiquer unique(tab_proprio_com$DEPT)\n                   selected = \"75\"),\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_proprio_com %&gt;%  \n        filter(DEPT == \"75\") %&gt;% \n        ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nEnfin, là encore, il faut introduire la réactivité et “connecter” la partie UI et la partie server, en remplaçant le nom du département dans le filter(dept == ) par le nom de l’inputId indiqué dans notre “radioButtons” :\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Nombre de propriétaires agrégé au niveau communal dans Paris et sa petite couronne\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes :\",\n                  min = 1,\n                  max = 50,\n                  value = 25),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département :\",\n                   choices = levels(tab_proprio_com$DEPT), #ou indiquer unique(tab_proprio_com$DEPT)\n                   selected = \"75\"),\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_proprio_com %&gt;%  \n        filter(DEPT == input$dept) %&gt;% \n        ggplot() + aes(x=nb_proprio) + geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nOn peut voir que le nombre de classes maximum de 50 n’est absolument pas pertinent pour certains départements qui ont peu de communes, c’est quelque chose qui pourra être modifiée bien sûr ultérieurement.",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#modification-du-graphique-selon-une-variable-au-choix-parmi-deux",
    "href": "10-Intro-a-Shiny-exemples.html#modification-du-graphique-selon-une-variable-au-choix-parmi-deux",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "10.5 Modification du graphique : selon une variable au choix parmi deux",
    "text": "10.5 Modification du graphique : selon une variable au choix parmi deux\nOn peut maintenant vouloir montrer un graphique (toujours le même histogramme) selon au choix deux variables : soit le nombre de propriétaires, soit le nombre de locataires. Il faut donc créer cette dernière variable de la même façon que précédemment pour les propriétaires, et l’ajouter au tableau précédent (qu’on renommera puisqu’il ne concerne plus les seuls propriétaires…).\n\ntab_locataires_com &lt;- RP_final %&gt;% \n              filter(STOCD %in% c(\"21\",\"22\",\"23\")) %&gt;% \n              mutate(STOCD=case_when(STOCD %in% c(\"21\",\"22\",\"23\") ~ \"nb_locataires\")) %&gt;% \n              somme(var_gpe=COM, nom_var=STOCD) %&gt;% \n              filter(COM!=\"ZZZZZ\")\n\ntab_st_occ &lt;- tab_proprio_com %&gt;% \n  left_join(tab_locataires_com, by=\"COM\")\n\n# pour supprimer les tables intermédiaires\nrm(tab_locataires_com, tab_proprio_com)\n\nProcédons comme précédemment : créons un nouveau widget avec par exemple selectInput(), dont l’inputID sera “variable” et l’argument choices = donne les deux variables choisies ; pour cela, on peut utiliser une fonction list() et indiquer le nom des deux variables, soient nb_proprio et nb_locataires.\nEt ensuite, dans la fonction server, remplaçons x=nb_proprio par x=input$variable et voyons si cela marche !\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Statut d'occupation des logements agrégé au niveau communal, selon le département\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes:\",\n                  min = 1,\n                  max = 50,\n                  value = 25),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département :\",\n                   choices = levels(tab_st_occ$DEPT),\n                   selected = \"75\"),\n      selectInput(inputId = \"variable\", \n                  label = \"Choix de la variable :\", \n                  choices = list(\"nb_proprio\", \"nb_locataires\"), \n                  selected = \"nb_proprio\"),\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_st_occ %&gt;%  \n        filter(DEPT == input$dept) %&gt;% \n        ggplot() + aes(x=input$variable) + \n                   geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nEt non cela ne fonctionne pas. En réalité, comme nous avons utilisé dans choices = une fonction list() qui fait appel à des variables de type caractère, la fonction ggplot() + aes(x = ) ne comprend pas que la variable appelée est bien une variable numérique (son contenu), elle croît en quelque sorte que c’est une variable caractère. Il faut donc dire à la fonction ggplot() ici que le nom de la variable est de type “string” mais qu’elle comporte bien des valeurs numériques donc compatible avec un histogramme : pour cela, au lieu de ggplot() + aes(x = ), il faut utiliser ggplot() + aes_string(x = ).\nRéessayons :\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Statut d'occupation des logements agrégé au niveau communal, selon le département\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Choix du nombre de classes :\",\n                  min = 1,\n                  max = 50,\n                  value = 25),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département :\",\n                   choices = unique(tab_st_occ$DEPT),\n                   selected = \"75\"),\n      selectInput(inputId = \"variable\", \n                  label = \"Choix de la variable :\", \n                  choices = list(\"nb_proprio\", \"nb_locataires\"), \n                  selected = \"nb_proprio\"),\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n  \n    output$histPlot &lt;- renderPlot({\n      tab_st_occ %&gt;%  \n        filter(DEPT == input$dept) %&gt;% \n        ggplot() + aes_string(x=input$variable) + \n                   geom_histogram(bins=input$classes)\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)\n\nEnfin, on peut ajouter en-dessous de l’histogramme un autre graphique, en l’occurence une boîte à moustache, et introduire une réactivité sur la base de données, ce qui permet un gain d’efficacité (en particulier en cas de base de données volumineuse) et ici d’éviter de réécrire deux fois le filtre dans les deux fonctions créant les deux graphiques :\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Statut d'occupation des logements au niveau communal, selon le département\"),\n  \n  # Définition du Widget - ici un slider en vue de construire un histogramme\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"classes\",\n                  label = \"Nombres de classes pour l'histogramme :\",\n                  min = 1,\n                  max = 50,\n                  value = 25),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département :\",\n                   choices = unique(tab_st_occ$DEPT), #ou indiquer 'nom_dept'\n                   selected = \"75\"),\n      selectInput(inputId = \"variable\", \n                  label = \"Choix de la variable :\", \n                  choices = list(\"nb_proprio\", \"nb_locataires\"), \n                  selected = \"nb_proprio\"),\n    ),\n    \n    # Graphe montré à l'utilisateur\n    mainPanel(\n      plotOutput(\"histPlot\"),\n      plotOutput(\"boxPlot\")\n    )\n  )\n)\n\n  server &lt;- function(input, output) {\n    \n    # Base réactive\n    tab_st_occ_react &lt;- reactive({\n      tab_st_occ %&gt;%  \n      filter(DEPT == input$dept)\n    })\n    \n    output$histPlot &lt;- renderPlot({\n      tab_st_occ_react() %&gt;% \n        ggplot() + aes_string(x=input$variable) + geom_histogram(bins=input$classes)\n      \n    })\n    \n    output$boxPlot &lt;- renderPlot({\n      tab_st_occ_react() %&gt;%  \n        ggplot() + aes_string(x = input$variable) + \n        geom_boxplot() + \n        scale_x_continuous(limits=c(0,quantile(tab_st_occ_react()[[input$variable]], 0.75)*2)) +\n        labs(caption=\"Rq : les valeurs supérieures à 2 fois le Q3 de la distribution ne sont pas affichées sur le graphique\", x=\"\", y=\"\") +\n        theme(plot.caption = element_text(hjust=0, size=11.5))\n    })\n    \n  }\n  \nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#application-avec-un-tableau-et-un-graphique-sur-une-autre-base-de-données",
    "href": "10-Intro-a-Shiny-exemples.html#application-avec-un-tableau-et-un-graphique-sur-une-autre-base-de-données",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "11.1 Application avec un tableau et un graphique sur une autre base de données",
    "text": "11.1 Application avec un tableau et un graphique sur une autre base de données\nEn repartant de la base JOCAS des offres d’emplois reçues via Pôle emploi en 2020 sur Paris et sa petite couronne, nous allons créer une autre application en mettant en haut un tableau général récapitulant les informations suivantes : le nombre d’offres en CDD, le nombre d’offres en intérim, la durée moyenne des offres en CDD et la durée moyenne des offres en intérim ; puis en-dessous de ce tableau, on va ajouter un graphique (barplot) qui va représenter le “top 5” de la durée moyenne la plus élevée des offres en CDD ou intérim selon le mois de publication et selon le département.\nAinsi, le premier tableau ne sera pas à ce stade réactif, alors que le graphique le sera. Il y aura par conséquent deux widgets, l’un pour choisir le mois de publication considéré et l’autre pour choisir le département. Pour le tableau, vous pouvez utiliser le package gt() et la fonction gt_output() pour l’appel du tableau dans la partie UI associée à la fonction render_gt() dans la partie server.\nCela doit vous donner ceci :\n\n\n# Chargement des librairies\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(RColorBrewer)\nlibrary(forcats)\n\n\n# Chargement du fichier et création variables\"\nOffresPE_2020 &lt;- readRDS(\"data/OffresPE_2020.Rdata\")\nOffresPE_2020 &lt;- OffresPE_2020  %&gt;% \n  mutate(mois_publication = months(date_sitePublicationDay),\n         mois_publication = factor(mois_publication, \n                                   levels = c( \"janvier\",\"février\",\"mars\",\"avril\", \"mai\", \"juin\",\"juillet\",\n                                                \"août\",\"septembre\", \"octobre\", \"novembre\", \"décembre\")),\n         location_departement = factor(OffresPE_2020$location_departement),\n         secteurs=as.factor(case_when(entrepriseSecteur_NAF21 %in% c(\"C\", \"D\", \"E\") ~ \"Industrie\",\n                                      entrepriseSecteur_NAF21 ==\"F\" ~ \"Construction\",\n                                      entrepriseSecteur_NAF21 ==\"G\" ~ \"Commerce\",\n                                      entrepriseSecteur_NAF21 ==\"H\" ~ \"Transports\",\n                                      entrepriseSecteur_NAF21 ==\"I\" ~ \"Hébergement/restauration\",\n                                      entrepriseSecteur_NAF21 ==\"J\" ~ \"Info/com\",\n                                      entrepriseSecteur_NAF21 %in% c(\"K\", \"L\") ~ \"Activités financières et immo\",\n                                      entrepriseSecteur_NAF21 ==\"M\" ~ \"Activités spécialisées, scientifiques et techniques\",\n                                      entrepriseSecteur_NAF21 ==\"N\" ~ \"Activités de services administratifs et de soutien\",\n                                      entrepriseSecteur_NAF21 ==\"O\" ~ \"Administration publique\",\n                                      entrepriseSecteur_NAF21 ==\"P\" ~ \"Enseignement\",\n                                      entrepriseSecteur_NAF21 ==\"Q\" ~ \"Santé humaine et action sociale\",\n                                      entrepriseSecteur_NAF21 ==\"R\" ~ \"Arts, spectacles et activités récréatives\",\n                                      entrepriseSecteur_NAF21 ==\"S\" ~ \"Autres activités de service\",\n                                      entrepriseSecteur_NAF21 ==\"T\" ~ \"Activités des ménages en tant qu'employeurs\",\n                                      entrepriseSecteur_NAF21 == \"\" ~ \"Inconnu\",\n                                      TRUE ~ entrepriseSecteur_NAF21)))\n\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Caractéristiques des offres d'emplois en CDD et intérim en 2020 sur Paris et sa petite couronne\"),\n  \n  br(),\n  \n  # Définition du ou des Widgets\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(inputId = \"mois\", \n                  label = \"Choix du mois de publication de l'offre\", \n                  choices = levels(OffresPE_2020$mois_publication),\n                  selected = \"janvier\"),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département\",\n                   choices = levels(OffresPE_2020$location_departement),\n                   selected = \"75\")\n\n      ),\n    \n    # Tableau et graphe montré à l'utilisateur\n    mainPanel(\n      gt_output(\"tab\"),\n\n      br(),\n      br(),\n      \n      plotOutput(\"barplot\")    \n    )\n  )\n)\n\n\nserver &lt;- function(input, output) {\n  \n  output$tab &lt;- render_gt({\n  OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n               entrepriseSecteur_NAF21!=\"U\") %&gt;% \n      count(contractType) %&gt;% \n      pivot_wider(names_from = contractType, values_from = n) %&gt;% \n      rename(\"Nombre de missions d'intérim\"=\"MIS\",\n             \"Nombre de CDD\"=\"CDD\") %&gt;% \n      add_column(\"Durée moyenne des contrats, en jours\" = round(mean(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                     !is.na(OffresPE_2020$contractDuration_value), ]$contractDuration_value)),\n                 \"Durée médiane des contrats, en jours\" = round(median(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                      !is.na(OffresPE_2020$contractDuration_value), ]$contractDuration_value))) %&gt;% \n      gt() %&gt;%  \n      fmt_number(columns= 1:2, sep_mark = \" \", decimals = 0) %&gt;% \n      tab_header(title=md(\"Nombre et durée des contrats de travail (CDD ou intérim) proposés dans les offres d'emploi de Pôle emploi en 2020 sur Paris et sa petite couronne\"))\n  })\n\n\n  output$barplot &lt;- renderPlot({\n  OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n               entrepriseSecteur_NAF21!=\"U\" & \n               mois_publication == input$mois & location_departement==input$dept) %&gt;% \n      group_by(secteurs) %&gt;% \n      summarise(moy_duree = round(mean(contractDuration_value))) %&gt;% \n      arrange(desc(moy_duree)) %&gt;% slice(1:5) %&gt;% \n      ggplot() + aes(x = moy_duree, y = fct_reorder(secteurs, moy_duree))  + \n      geom_bar(stat=\"identity\", fill=\"darkgoldenrod1\")  +\n      geom_text(aes(label=moy_duree), position = position_stack(vjust=0.5), size=4.5) +\n      labs(title=paste(\"Top 5 des secteurs d'activité ayant des offres d'emploi en CDD \\net missions d'intérim avec les durées moyennes en jours les \\nplus élevées\",\n                       \"en\", input$mois, \"dans le\", input$dept), \n           x = \"\", y = \" \", caption=\"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020.\") +\n      theme_classic() +\n      theme(legend.position = \"none\", plot.title=element_text(size=16),\n            plot.caption=element_text(size=11),\n            axis.text.y = element_text(size=12.5),\n            axis.text.x = element_text(size=11),\n            )\n\n  })\n  \n}\n\n\nshinyApp(ui = ui, server = server)\n\nPar rapport aux exemples précédents déjà réalisés sur Shiny, nous n’avons pas beaucoup ajouté de choses nouvelles : un peu de langage html (br()) pour insérer des espaces entre le tableau et le graphique, ou le titre général et le reste des éléments de l’application ; puis une fonction de condition à l’intérieur du labs() de Ggplot et avec la fonction paste() pour, d’une part, que le titre change selon le mois choisi et le déartement choisi par l’utilisateur.\nOn va maintenant rendre le tableau réactif selon le département choisi.\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Caractéristiques des offres d'emplois en CDD et intérim en 2020 sur Paris et sa petite couronne\"),\n  \n  br(),\n  \n  # Définition du Widget\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(inputId = \"mois\", \n                  label = \"Choix du mois de publication de l'offre\", \n                  choices = levels(OffresPE_2020$mois_publication),\n                  selected = \"janvier\"),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département\",\n                   choices = levels(OffresPE_2020$location_departement),\n                   selected = \"75\")\n\n      ),\n    \n    # Tableau et graphe montré à l'utilisateur\n    mainPanel(\n      gt_output(\"tab\"),\n\n      br(),\n      br(),\n      \n      plotOutput(\"barplot\")    \n    )\n  )\n)\n\n\nserver &lt;- function(input, output) {\n  \n  output$tab &lt;- render_gt({\n  OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n               entrepriseSecteur_NAF21!=\"U\" & location_departement==input$dept) %&gt;% \n      count(contractType) %&gt;% \n      pivot_wider(names_from = contractType, values_from = n) %&gt;% \n      rename(\"Nombre de missions d'intérim\"=\"MIS\",\n             \"Nombre de CDD\"=\"CDD\") %&gt;% \n      add_column(\"Durée moyenne des contrats, en jours\" = round(mean(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                     !is.na(OffresPE_2020$contractDuration_value) &\n                                                                       OffresPE_2020$location_departement==input$dept, ]$contractDuration_value )),\n                 \"Durée médiane des contrats, en jours\" = round(median(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                       !is.na(OffresPE_2020$contractDuration_value) &\n                                                                       OffresPE_2020$location_departement==input$dept, ]$contractDuration_value))) %&gt;% \n      gt() %&gt;%  \n      fmt_number(columns= 1:2, sep_mark = \" \", decimals = 0) %&gt;% \n      tab_header(title=paste(\"Nombre et durée des contrats de travail (CDD ou intérim) proposés dans les offres d'emploi de Pôle emploi en 2020 dans le\", input$dept))\n  })\n\n\n  output$barplot &lt;- renderPlot({\n  OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n               entrepriseSecteur_NAF21!=\"U\" & \n               mois_publication == input$mois & location_departement==input$dept) %&gt;% \n      group_by(secteurs) %&gt;% \n      summarise(moy_duree = round(mean(contractDuration_value))) %&gt;% \n      arrange(desc(moy_duree)) %&gt;% slice(1:5) %&gt;% \n      ggplot() + aes(x = moy_duree, y = fct_reorder(secteurs, moy_duree))  + \n      geom_bar(stat=\"identity\", fill=\"darkgoldenrod1\")  +\n      geom_text(aes(label=moy_duree), position = position_stack(vjust=0.5), size=4.5) +\n      labs(title=paste(\"Top 5 des secteurs d'activité ayant des offres d'emploi en CDD \\net missions d'intérim avec les durées moyennes en jours les \\nplus élevées\",\n                       \"en\", input$mois, \"dans le\", input$dept), \n           x = \"\", y = \" \", caption=\"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020.\") +\n      theme_classic() +\n      theme(legend.position = \"none\", plot.title=element_text(size=16),\n            plot.caption=element_text(size=11),\n            axis.text.y = element_text(size=12.5),\n            axis.text.x = element_text(size=11))\n\n  })\n  \n}\n\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#introduction-dune-réactivité-appliquée-à-la-table-de-données",
    "href": "10-Intro-a-Shiny-exemples.html#introduction-dune-réactivité-appliquée-à-la-table-de-données",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "11.2 Introduction d’une réactivité appliquée à la table de données",
    "text": "11.2 Introduction d’une réactivité appliquée à la table de données\nOn peut rendre maintenant la base de données réactive avec la fonction reactive({}). On l’avait vu, la fonction reactive() permet de créer un objet réactif qui est à la fois une entrée réactive et une sortie réactive, l’objet va donc se mettre à jour automatiquement si les entrées qu’il utilise changent, et il va automatiquement déclencher la mise à jour des sorties où il est utilisé.\nLa fonction permet techniquement de décomposer du code réactif et est utile lorsque certaines parties du code sont utilisées par plusieurs outputs car elle va permettre alors d’éviter des redondances. Cela peut être le cas lorsqu’on doit filtrer et/ou sélectionner des mêmes variables en input pour plusieurs outputs.\nIci, on va décomposer la partie ‘data’ du code précédent de la partie construction du graphique ; le rendu sera strictement le même ; mais cela peut être plus efficace en cas de long code et d’application complexe car en gros on va exécuter qu’une seule fois l’opération ‘data’ réalisée ici.\nAttention, la base réactive créée est une fonction, il faut donc l’appeler avec des parenthèses !\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Caractéristiques des offres d'emplois en CDD et intérim en 2020 sur Paris et sa petite couronne\"),\n  \n  br(),\n  \n  # Définition du Widget\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(inputId = \"mois\", \n                  label = \"Choix du mois de publication de l'offre\", \n                  choices = levels(OffresPE_2020$mois_publication),\n                  selected = \"janvier\"),\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département\",\n                   choices = levels(OffresPE_2020$location_departement),\n                   selected = \"75\")\n\n      ),\n    \n    # Tableau et graphe montré à l'utilisateur\n    mainPanel(\n      gt_output(\"tab\"),\n\n      br(),\n      br(),\n      \n      plotOutput(\"barplot\")    \n    )\n  )\n)\n\n\nserver &lt;- function(input, output) {\n  \n  output$tab &lt;- render_gt({\n  OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value & \n           !entrepriseSecteur_NAF21==\"U\" & location_departement==input$dept)) %&gt;% \n      count(contractType) %&gt;% \n      pivot_wider(names_from = contractType, values_from = n) %&gt;% \n      rename(\"Nombre de missions d'intérim\"=\"MIS\",\n             \"Nombre de CDD\"=\"CDD\") %&gt;% \n      add_column(\"Durée moyenne des contrats, en jours\" = round(mean(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                     !is.na(OffresPE_2020$contractDuration_value) &\n                                                                       OffresPE_2020$location_departement==input$dept, ]$contractDuration_value )),\n                 \"Durée médiane des contrats, en jours\" = round(median(OffresPE_2020[OffresPE_2020$contractType %in% c(\"CDD\", \"MIS\") & \n                                                                                       !is.na(OffresPE_2020$contractDuration_value) &\n                                                                       OffresPE_2020$location_departement==input$dept, ]$contractDuration_value))) %&gt;% \n      gt() %&gt;%  \n      fmt_number(columns= 1:2, sep_mark = \" \", decimals = 0) %&gt;% \n      tab_header(title=paste(\"Nombre et durée des contrats de travail (CDD ou intérim) proposés dans les offres d'emploi de Pôle emploi en 2020 dans le\", input$dept))\n  })\n\n   OffresPE_2020_react &lt;- reactive({\n    OffresPE_2020 %&gt;% \n      filter(contractType %in% c(\"CDD\", \"MIS\") & !is.na(contractDuration_value) & \n               !entrepriseSecteur_NAF21==\"U\" & \n               mois_publication == input$mois & location_departement==input$dept) %&gt;% \n      group_by(secteurs) %&gt;%  \n      summarise(moy_duree = round(mean(contractDuration_value))) %&gt;% \n      arrange(desc(moy_duree)) %&gt;% slice(1:5)\n   })\n\n  output$barplot &lt;- renderPlot({\n  OffresPE_2020_react() %&gt;% \n      ggplot() + aes(x = moy_duree, y = fct_reorder(secteurs, moy_duree))  + \n      geom_bar(stat=\"identity\", fill=\"darkgoldenrod1\")  +\n      geom_text(aes(label=moy_duree), position = position_stack(vjust=0.5), size=4.5) +\n      labs(title=paste(\"Top 5 des secteurs d'activité ayant des offres d'emploi en CDD \\net missions d'intérim avec les durées moyennes en jours les \\nplus élevées\",\n                       \"en\", input$mois, \"dans le\", input$dept), \n           x = \"\", y = \" \", caption=\"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020.\") +\n      theme_classic() +\n      theme(legend.position = \"none\", plot.title=element_text(size=16),\n            plot.caption=element_text(size=11),\n            axis.text.y = element_text(size=12.5),\n            axis.text.x = element_text(size=11))\n\n  })\n  \n}\n\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "10-Intro-a-Shiny-exemples.html#introduction-dune-réactivité-sur-les-inputs-contexte-réactif",
    "href": "10-Intro-a-Shiny-exemples.html#introduction-dune-réactivité-sur-les-inputs-contexte-réactif",
    "title": "10  La création d’une application Shiny “pas à pas” avec l’une de nos bases de données",
    "section": "11.3 Introduction d’une réactivité sur les inputs (contexte réactif)",
    "text": "11.3 Introduction d’une réactivité sur les inputs (contexte réactif)\nOn va maintenant introduire un contexte réactif.\nPour cela, on va repartir de la base du RP, puisqu’on peut y distinguer les départements et les communes, en s’intéressant à la répartition de la population de 15-64 ans selon le type d’activité, et donc par département et commune. On va de façon comparable à ce qu’on a fait précédemment, créer en haut un tableau qui donnera cette répartition pour le département ; puis en-dessous un graphique qui montrera cette répartition pour une des communes de ce département. On aura donc deux widgets, un pour le choix du département et un pour le choix de la commune. On veut que lorsqu’on choisit Paris en département par exemple, le widget de la commune ne nous montre que les arrondissements de Paris (et non toutes les communes des 4 départements de notre champ), etc.\nOn peut pour cela utiliser la fonction observe() : on l’utilise donc quand un input change.\nIl va falloir ici utiliser à l’intérieur de la fonction observe() une condition if ... else ... : on part du principe qu’on affiche d’abord automatiquement le département “75”, lorsque l’utilisateur appuie sur le bouton du choix de département du widget radioButtons, le widget selectInput doit être actualisé en permettant les seuls choix de communes de Paris donc les arrondissements ; de même pour les autres départements.\nIl faut donc utiliser la fonction observe(), une condition if ... else ... et une actualisation des widgets avec la fonction updateSelectInput().\nL’image suivante vous donne un aperçu de ce qu’on devrait avoir pour Paris :\n\n\n# On corrige les codes communes avec la table de passage suivante\ntab_passage &lt;- readRDS(file = \"F:/Enseignements/Enseignements Univ. Paris Cite 2020-xx/Data Mining_M2 PISE/Cours 2023-2025/Tables passage géo/zip_code_to_com_code.RDS\")\n\ntab_passage %&gt;% filter(!zip_code %in% c(\"13382\", \"13591\", \"28011\", \"59708\", \"69307\"))\n\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;% rename(zip_code = location_zipcode, zip_name=location_label) %&gt;% \n  mutate(zip_code = as.character(zip_code)) %&gt;% \n  left_join(tab_passage, by=c(\"zip_code\", \"zip_name\"))\n\n\n# On crée une variable de contrat avec moins de modalités\nOffresPE_2020 &lt;- OffresPE_2020 %&gt;% \n       mutate(type_contrat=as.factor(case_when(contractType==\"MIS\" ~ \"Intérim\",\n                                               contractType %in% c(\"CDS\",\"SAI\",\"TTI\", \"DDI\") ~ \"CDD\",\n                                               contractType %in% c(\"CCE\", \"REP\", \"DIN\") ~ \"Autres types\",\n                                               contractType %in% c(\"Independant\", \"Franchise\") ~ \"Indépendant ou franchise\",\n                                               TRUE ~ contractType)),\n              com_code = as.factor(com_code))\n\n\n# Définition UI et Server de l'application Shiny\nui &lt;- fluidPage(\n  # Titre de l'application\n  titlePanel(\"Types de contrat de travail des offres d'emplois proposées par Pôle emploi en 2020 sur Paris et sa petite couronne\"),\n  \n  br(),\n  \n  # Définition du Widget\n  sidebarLayout(\n    sidebarPanel(\n      radioButtons(inputId = \"dept\", \n                   label = \"Choix du département pour le tableau et le graphique\",\n                   choices = levels(OffresPE_2020$location_departement),\n                   selected = \"75\"),\n      selectInput(inputId = \"commune\", \n                  label = \"Choix de la commune pour le graphique\", \n                  choices = unique(OffresPE_2020$com_code),\n                  selected = \"75113\")\n      ),\n\n    \n    # Tableau et graphe montré à l'utilisateur\n    mainPanel(\n      gt_output(\"tab\"),\n\n      br(),\n      br(),\n      \n      plotOutput(\"barplot\")    \n    )\n  )\n)\n\n\nserver &lt;- function(input, output) {\n\n   observe({\n     input$dept\n     if(input$dept == \"75\"){\n       updateSelectInput(inputId = \"commune\",\n                         choices = unique(OffresPE_2020[OffresPE_2020$location_departement==\"75\", ]$com_code),\n                         selected = \"75113\")\n      }\n     else {updateSelectInput(inputId = \"commune\",\n                            choices = unique(OffresPE_2020[OffresPE_2020$location_departement==input$dept, ]$com_code),\n                            selected = input$variable)\n    }\n  })\n   \n   \n  output$tab &lt;- render_gt({\n  OffresPE_2020 %&gt;% \n      filter(location_departement==input$dept) %&gt;% \n      count(type_contrat) %&gt;% \n      mutate(Pourcentage=round(prop.table(n)*100,1)) %&gt;% \n      arrange(desc(Pourcentage)) %&gt;% \n      adorn_totals(\"row\") %&gt;% \n      rename(Effectif=n, \"Type de contrat\"=type_contrat) %&gt;% \n      gt() %&gt;% \n      fmt_number(columns = 2, sep_mark = \" \", decimals = 0) %&gt;% \n      tab_header(title = paste(\"Département affiché :\", input$dept))\n\n  })\n\n    \n   OffresPE_2020_react &lt;- reactive({\n    OffresPE_2020 %&gt;% \n       filter(location_departement==input$dept & com_code==input$commune)\n     \n   })\n\n  \n  output$barplot &lt;- renderPlot({\n  OffresPE_2020_react() %&gt;% \n      filter(com_code==input$commune) %&gt;% \n      count(type_contrat) %&gt;% \n      mutate(Pourcentage=round(prop.table(n)*100,1)) %&gt;% \n      select(-n) %&gt;%\n      ggplot() + aes(x=fct_reorder(type_contrat, desc(Pourcentage)), y=Pourcentage)  + \n      geom_bar(stat=\"identity\", fill=\"darkgoldenrod1\")  +\n      geom_text(aes(label=Pourcentage), position = position_stack(vjust=0.5), size=4.5) +\n      labs(title=paste(\"Répartition des offres d'emploi par type de contrat de travail dans le\", input$commune), \n           x = \"\", y = \" \", caption=\"Source : Base 'JOCAS', offres d'emploi émanant uniquement de Pôle emploi (auj. France Travail), 2020.\") +\n      theme_classic() +\n      theme(legend.position = \"none\", plot.title=element_text(size=17),\n            plot.caption=element_text(size=11.5),\n            axis.text.y = element_text(size=11.5),\n            axis.text.x = element_text(size=11.5))\n\n  })\n  \n}\n\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Séances 4 et 5",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>La création d'une application Shiny \"pas à pas\" avec l'une de nos bases de données</span>"
    ]
  },
  {
    "objectID": "11-Clustering-theorique.html",
    "href": "11-Clustering-theorique.html",
    "title": "11  Clustering : aspects théoriques",
    "section": "",
    "text": "11.1 La classification ascendante hiérarchique (CAH)\nLes méthodes de clustering (ou typologie, ou segmentation, ou encore classification en français1) appartiennent à la famille des algorithmes d’apprentissage non supervisé, car nous n’avons pas de variable de sortie ou variable-cible.\nCe sont justement les algorithmes qui vont chercher à organiser les observations en groupes ou classes dit “clusters” en fonction de variables quantitatives choisies en entrée/input dans le modèle. L’algorithme va ensuite chercher à ce que ces “clusters” soient à la fois le plus similaire possible à l’intérieur/en leur sein (forte “similarité intraclasse”, on cherche alors à minimiser l’inertie intraclasse) et le plus distinctif/différent des autres groupes/classes (faible “similarité interclasse”, on parlera de maximisation de l’inertie interclasse). Ces observations peuvent être des individus, des entreprises, ou comme ici pour nous, un niveau territorial (la commune).\nSource : document de cours accessible ici http://iml.univ-mrs.fr/~reboul/ADD4-MAB.pdf\nIl y a deux principales méthodes de clustering : hiérarchique et non hiérarchique, la principale différence étant que pour la premiere on ne connaît pas par avance le nombre de groupes dans lesquels seront réparties nos observations ; alors que pour la seconde, on fixe au préalable le nombre de groupes.\nOn va étudier ici deux exemples : pour le clustering hiérarchique, on va utiliser la méthode la plus courante - la classification ascendante hiérarchique (CAH) - qui utilise un algorithme ascendant, c’est-à-dire agglomératif (les classes sont construites par agglomérations successives des objets deux à deux ; cette méthode s’oppose aux algorithmes descendants ou divisifs) ; et pour le clustering non hiérarchique, la méthode également la plus utilisée - les centres-mobiles ou la méthodes des K-means (très légèrement différente). Pour d’autres exemples, vous pouvez vous référer respectivement aux pages 244-251, et 252-255, du manuel de référence du cours (Husson, 2018).\nVoici une représentation générale d’un clustering hiérarhique :\nSource : document de cours accessible ici https://perso.univ-rennes1.fr/valerie.monbet/ExposesM2/2013/Classification2.pdf\nIl y a en gros 3 grandes étapes :\nUn schéma de 3 de ces distances permet de mieux visualiser ce dont il s’agit :\nSource : document de cours accessible ici https://r.developpez.com/tutoriels/programmation-graphe/livre-R-et-espace/?page=chapitre-7-methodes-de-classification\nOn doit ainsi aboutir à un arbre appelé dendogramme, dont le haut ou la “racine” est constituée d’une unique classe/cluster qui rassemble tous les individus, alors que le bas (l’ensemble des “feuilles”) constituent des clusters à un individu donc avec une homogénéité, par définition parfaite. Selon la méthode d’agrégation utilisée, les dendogrammes pourront avoir des formes bien différentes (c’est ce que nous verrons dans l’exemple d’application), il ne faut donc pas hésiter à tester différentes méthodes pour rendre plus robuste le résultat final c’est-à-dire la classification, en gros elle sera robuste si le “haut” de l’arbre ne change pas trop (= on a toujours les même 3 ou 4 ou 5 grosses classes).\nUn exemple d’application d’un clustering hiérarchique avec 7 individus, basée sur une distance euclidienne et la méthode de Ward, est disponible ici.",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Clustering : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "11-Clustering-theorique.html#la-classification-ascendante-hiérarchique-cah",
    "href": "11-Clustering-theorique.html#la-classification-ascendante-hiérarchique-cah",
    "title": "11  Clustering : aspects théoriques",
    "section": "",
    "text": "Représentation graphique clustering hiérarchique\n\n\n\n\n\nune première étape, facultative, car cela dépend de la nature des données : on centre et réduit les variables, on dit également qu’on “standardise” les variables. Cela est indispensable quand les variables ont des unités différentes (le poids et la taille d’un individu) ; si elles ont des unités similaires (c’est notre cas ici), il faut choisir de le faire ou non. Souvent, on va choisir de “standardiser” car on peut avoir des variables avec des écarts-types importants ce qui peut créer un biais (en faveur de ces variables, c’est-à-dire en leur donnant un poids plus important dans l’analyse) lors de la construction de la matrice de distances.\nune seconde étape consiste à créer une matrice des distances (ou des dissimilarités) car la construction de l’arbre (cf. ci-dessous) repose sur les distances entre observations/individus : l’idée est de chercher les individus les plus proches ou les plus ressemblants ; on commence donc par calculer la matrice des distances des individus deux à deux, puis on rassemble les deux plus proches dans un nouvel élément ce qui crée une matrice des distances sur les n-1 individus, ensuite on réitère le processus - on crée une matrice des distances rassemblant les deux individus les plus proches dans un nouveau groupe, etc. - jusqu’à ce qu’on ne dispose plus que d’un seul élément. Dans cette étape, on choisit le type de distance utilisé, c’est-à-dire le critère de ressemblance entre les individus. Sans rentrer ici plus dans les détails, la méthode de distance la plus utilisée et (ou car) la plus intuitive est la distance euclidienne. Mais par exemple, si nos variables ne sont pas mesurées en effectifs mais en proportion, il faudra plutôt utiliser la distance du khi-deux. Autre exemple, lorsque les variables seront qualitatives de type binaire (0/1), alors ce sera plutôt l’indice de similarité de Jaccard qui sera utilisé.\nenfin, la troisième étape est la méthode d’agrégation : dans la construction de la matrice de distance, après la 1ère étape (n-1 individus), ce seront progressivement des groupes d’individus dont on comparera la distance, il faut donc savoir comment calculer cette distance entre groupes (et non plus seulement entre individus) : est-ce qu’on prend le point représentant l’individu moyen du groupe ? Ou bien celui qui est à l’extrêmité du groupe ? Etc. Là aussi, il faut donc choisir cette méthode d’agrégation parmi un ensemble de méthodes (lien simple ou minimum, lien maximum, lien moyen, lien entre les centroïdes/centres de gravité ou barycentre, critère de Ward) : la plus utilisée est le critère de Ward, notamment lorsqu’on utilise une distance euclidienne dans l’étape précédente. Ce critère se base sur la décomposition de l’inertie totale (somme du carré des distances de chaque point au centre) en une inertie intraclasse et une inertie interclasse ; il consiste ensuite à minimiser la perte d’inertie intraclasse à chaque agrégation de classes, pour que les classes restent le plus homogène possible.\n\n\n\n\n\nRepresentation graphique de 3 critères d’agrégation",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Clustering : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "11-Clustering-theorique.html#la-méthode-des-centres-mobiles-et-sa-variante-les-k-means",
    "href": "11-Clustering-theorique.html#la-méthode-des-centres-mobiles-et-sa-variante-les-k-means",
    "title": "11  Clustering : aspects théoriques",
    "section": "11.2 La méthode des centres mobiles et sa variante, les K-means",
    "text": "11.2 La méthode des centres mobiles et sa variante, les K-means\nL’objectif est cette fois de construire une partition d’une population en k “clusters”, ce nombre k étant fixé avant ou a priori. C’est la principale différence en réalité par rapport à la méthode précédente, et le résultat en sera une partition unique des données (contrairement à la CAH qui donne une sorte de hiérarchie de partitions avec le dendogramme, à partir de laquelle il faut choisir le nombre de classes).\nL’algorithme des centres mobiles repose sur un processus itératif de plusieurs étapes : on détermine aléatoirement (c’est-à-dire au hasard) k individus/observations comme centres provisoires de classes, et on affecte chaque individu à la classe dont le centre est le plus proche, ce qui crée une première partition ; ensuite, on procède à un nouveau calcul des centres de gravité des classes de cette première partition, on redistribue les individus dans la classe dont le centre est le plus proche, ce qui permet d’aboutir à une seconde partition alternative ; on répète ce processus jusqu’à convergence (selon un critère que l’on peut définir), c’est-à-dire jusqu’à ce qu’aucun individu ne change de classe, ou lorsque l’inertie intra-classe ne diminue plus, ou encore lorsque les centres de classes sont stables, ou lorsque tout simplement on a atteint le nombre d’itérations que l’on avait fixé. Il y a donc, ici aussi (mais plus implicitement), une minimisation de l’inertie intra-classe. Une variante est qu’une actualisation ou un recalcul des centres de classe peut être fait dès qu’un individu change de classe ; néanmoins dans cette variance, l’ordre des individus joue dans le résultat final.\nVoici une représentation graphique illustrant la méthode : \nLégèrement différente, la méthode des k-means va recalculer le centre de classe à chaque fois qu’un nouvel individu y est introduit, alors que précédemment on attendait que tous les individus soient affectés dans des groupes pour recalculer le centre de classe. Le nouveau calcul du cente de classe est donc ici effectué dès qu’un individu change de classe.\nL’une des limites de cette méthode (et sa variante) est que la partition finale, résultat de ce processus itératif, dépend souvent des centres initiaux de classes qui ont été choisis, c’est pourquoi en pratique il est préférable d’exécuter plusieurs fois la procédure, et comme précédemment de choisir la partition la plus stable/robuste.\nCette méthode est souvent utilisée lorsque l’on a de grosses bases de données sur lesquelles faire tourner une CAH est très coûteuse en temps ; toutefois, le fait de devoir répéter plusieurs fois la procédure jusqu’à stabilité des classes peut atténuer cette avantage de rapidité de calcul pour les grandes bases. On peut l’utiliser aussi en complément d’une CAH là aussi sur de grosses bases de données, plus précisément comme étape préalable à une CAH, l’idée étant de choisir un très grand nombre de centres de classes pour réaliser la CAH sur ces centres considérés comme les individus, et ensuite aboutir à un nombre plus petit de classes finales, c’est ce qu’on appelle la méthode de classification ou clustering mixte.",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Clustering : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "11-Clustering-theorique.html#footnotes",
    "href": "11-Clustering-theorique.html#footnotes",
    "title": "11  Clustering : aspects théoriques",
    "section": "",
    "text": "Attention néanmoins à l’usage du terme “classification” car en anglais et dans la plupart des ouvrages de Data Science et de Machine Learning, ce terme renvoie aux techniques d’analyse prédictive dont la variable cible (d’intérêt) est qualitative (en opposition aux régressions pour lesquelles la variable cible est quantitative). L’usage du terme “clustering” est ainsi privilégié.↩︎",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Clustering : aspects théoriques</span>"
    ]
  },
  {
    "objectID": "12-Clustering-application.html",
    "href": "12-Clustering-application.html",
    "title": "12  Clustering : application sur le RP 2019",
    "section": "",
    "text": "12.1 Choix des variables et préparation du tableau final\nA partir de la base du RP2019, l’objectif de notre analyse est de décrire des groupes de communes qui se ressemblent ou sont relativement homogènes, c’est-à-dire qui ont des caractéristiques proches. Mais, bien sûr, les méthodes de clustering peuvent être appliquées à toutes sortes de problématiques et de données.\nPour cela, on doit avoir un tableau avec n individus ou observations (lignes) et p variables (colonnes), la mesure des variables peut être des effectifs, mais aussi des proportions. L’idée étant de regrouper nos communes en classes homogènes (=clusters) en un nombre plus restreint, nos observations sont donc constituées ici par les communes. Il faut ensuite choisir sur quelles caractéristiques on va les regrouper et chercher une certaine homogénéité. Cela peut être à partir de différentes choses selon notre base de données : caractéristiques socio-professionnelles de la personne de référence du ménage, caractéristiques des logements, etc.",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Clustering : application sur le RP 2019</span>"
    ]
  },
  {
    "objectID": "12-Clustering-application.html#choix-des-variables-et-préparation-du-tableau-final",
    "href": "12-Clustering-application.html#choix-des-variables-et-préparation-du-tableau-final",
    "title": "12  Clustering : application sur le RP 2019",
    "section": "",
    "text": "12.1.1 Variable socio-professionnelle caractérisant la personne de référence du ménage\nOn va dans cet exemple (communes de Paris et sa petite couronne) s’intéresser aux caractéristiques socio-professionnelles de la population de 15 ans ou plus : on aura en lignes nos n communes des 4 départements et en colonnes nos p variables d’entrées, soient par exemple le nombre d’habitants, le nombre d’individus qui sont actuellement chômeurs, le nombre de personnes en emploi, le nombre de cadres, etc.\nOn va réaliser ici un exemple très simple en ne prenant qu’une variable reconstruite à partir de celle de la catégorie socio-professionnnelle (CS1) qui a actuellement 8 modalités et de celle du type d’activité (TACT), cela permettant de distinguer les actifs en emploi des chômeurs. Si l’on prend plus de variables, il faut faire attention à ce que certaines modalités ne se recoupent pas entre elles, ou quand l’information est trop proche - par exemple la condition d’emploi et le type d’activité. Pour cela, il faut étudier les corrélations entre les variables finalement obtenues, avec les fonctions cor() ou corrplot(cor()) du package corrplot par exemple. Mais si le nombre de variables prises en compte est importante, il peut être également plus pertinent de procéder avant la méthode de clustering à une méthode d’analyse factorielle.  \nRegardons d’abord pour cette variable - CS1 - si un regroupement et un recodage des modalités est nécessaire.\n\n# Chargement des librairies\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(gt)\n\n# Chargement des tables\nRP_final &lt;- readRDS(file = \"data/RP_final.Rdata\")\nmeta &lt;- readRDS(file = \"data/meta.Rdata\")\n\n# Appel fonctions\nsource(\"fonctions/fonctions.R\")\n\nmeta %&gt;% \n  select(COD_VAR, COD_MOD, LIB_MOD) %&gt;% \n  filter(COD_VAR %in% c(\"CS1\", \"TACT\"))\n\n   COD_VAR COD_MOD\n1      CS1       1\n2      CS1       2\n3      CS1       3\n4      CS1       4\n5      CS1       5\n6      CS1       6\n7      CS1       7\n8      CS1       8\n9     TACT      11\n10    TACT      12\n11    TACT      21\n12    TACT      22\n13    TACT      23\n14    TACT      24\n15    TACT      25\n                                                                      LIB_MOD\n1                                                    Agriculteurs exploitants\n2                                 Artisans, commerçants et chefs d'entreprise\n3                           Cadres et professions intellectuelles supérieures\n4                                                  Professions Intermédiaires\n5                                                                    Employés\n6                                                                    Ouvriers\n7                                                                   Retraités\n8                              Autres personnes sans activité professionnelle\n9  Actifs ayant un emploi, y compris sous apprentissage ou en stage rémunéré.\n10                                                                   Chômeurs\n11                                                  Retraités ou préretraités\n12               Élèves, étudiants, stagiaires non rémunéré de 14 ans ou plus\n13                                                            Moins de 14 ans\n14                                                  Femmes ou hommes au foyer\n15                                                            Autres inactifs\n\n# Fonction \"tableau\" créée dans la section 6\nRP_final %&gt;% filter(!AGER20 %in% c(\"2\",\"5\", \"10\",\"14\")) %&gt;% \n  tableau(var_quali = CS1, nom_var_quali = \"PCS\") %&gt;% gt()\n\n\n\n\n\n\n\nPCS\nEffectif\nPourcentage\n\n\n\n\n1\n890.8146\n0.0\n\n\n2\n187816.5390\n3.4\n\n\n3\n1202479.4687\n21.5\n\n\n4\n838616.6681\n15.0\n\n\n5\n872375.2789\n15.6\n\n\n6\n416074.6945\n7.4\n\n\n7\n1020480.0552\n18.2\n\n\n8\n1055867.3440\n18.9\n\n\nTotal\n5594600.8630\n100.0\n\n\n\n\n\n\n\nIl faut donc supprimer la modalité “1” qui correspond aux agriculteurs car trop peu représentés sur ce champ, mais pour le reste on peut laisser comme cela.\n\n\n12.1.2 Création du tableau de contingence\nPour créer le tableau de contigence donnant le nombre d’individus pour chacune des modalités de cette variable et pour chaque commune, on va créer une fonction qu’on va appeler tab_cont_n, pour avoir en ligne les communes et en colonne chaque modalité de la variable en question :\n\ntab_cont_n &lt;- function(data, ..., nom_var, var, prefix_var)\n{\n  tab_n &lt;- data %&gt;% \n            group_by(...) %&gt;%\n            summarise({{ nom_var }} := round(sum(IPONDI))) %&gt;% \n            pivot_wider(names_from = {{ var }}, values_from = {{ nom_var }},\n                        values_fill = 0, names_prefix = prefix_var)\n  \n  return(tab_n)\n}\n\nOn peut l’intégrer dans notre script fonctions.R pour pouvoir l’utiliser plus tard en appelant simplement ce fichier en début de code.\n  On crée maintenant notre tableau de contingence, en créant comme déjà mentionné une variable croisant l’information sur la catégorie socio-professionnelle et celle sur le statut d’activité regroupé en emploi, chômage, retraités ou autres inactifs.\n\n# On enlève les agriculteurs, , la commune sans dénomination et les moins de 15 ans\ncat_soc &lt;- RP_final %&gt;% \n  filter(CS1!=\"1\" & COM!=\"ZZZZZ\" &!AGER20 %in% c(\"2\",\"5\", \"10\",\"14\")) %&gt;%  \n  mutate(CS_empcho = as.factor(case_when(CS1 == \"2\" & TACT==\"11\" ~ \"Arti_com\",\n                                         CS1 == \"3\" & TACT==\"11\" ~ \"Cadres\",\n                                         CS1 == \"4\" & TACT==\"11\" ~ \"PI\",\n                                         CS1 == \"5\" & TACT==\"11\" ~ \"Employés\",\n                                         CS1 == \"6\" & TACT==\"11\" ~ \"Ouvriers\",\n                                         CS1 != \"7\" & TACT==\"12\" ~ \"Chômeurs\",\n                                         CS1 == \"7\" & TACT==\"21\" ~ \"Retraités\",\n                                         TRUE ~ \"Autres inactifs\"))) %&gt;% \n  tab_cont_n(COM, CS_empcho, nom_var=cat_soc, var=CS_empcho, prefix_var=\"nb_\")\ncat_soc %&gt;% head(10)\n\n# A tibble: 10 × 9\n# Groups:   COM [10]\n   COM   nb_Arti_com `nb_Autres inactifs` nb_Cadres nb_Chômeurs nb_Employés\n   &lt;chr&gt;       &lt;dbl&gt;                &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 75101         828                 2249      4294         935        1268\n 2 75102        1086                 2320      7056        1375        1761\n 3 75103        1619                 4287     10160        2085        2617\n 4 75104        1247                 4100      7793        1863        2344\n 5 75105        1869                11010     15853        2611        3494\n 6 75106        1788                 8296     10170        1842        2348\n 7 75107        2462                 8257     12641        2165        3603\n 8 75108        1801                 5559      9702        1565        2846\n 9 75109        2736                 7069     19617        3478        4083\n10 75110        2792                11091     24147        6343        6956\n# ℹ 3 more variables: nb_Ouvriers &lt;dbl&gt;, nb_PI &lt;dbl&gt;, nb_Retraités &lt;dbl&gt;\n\n\nOn a donc 136 lignes correspondant à 136 communes de nos 4 départements, et 9 variables.\nOn va rajouter le nom des communes comme identifiant dans le tableau, c’est-à-dire dans le nom de la 1ère colonne, avec la fonction column_to_rownames(). Cela peut être conseillé pour la procédure de clustering, afin que chaque commune soit bien identifiée par son nom (label) ; on verra toutefois dans notre exemple que cela devient illisible si on a trop de communes/individus.\n\ncat_soc &lt;- cat_soc %&gt;% column_to_rownames(var = \"COM\")\ncat_soc\n\n      nb_Arti_com nb_Autres inactifs nb_Cadres nb_Chômeurs nb_Employés\n75101         828               2249      4294         935        1268\n75102        1086               2320      7056        1375        1761\n75103        1619               4287     10160        2085        2617\n75104        1247               4100      7793        1863        2344\n75105        1869              11010     15853        2611        3494\n75106        1788               8296     10170        1842        2348\n75107        2462               8257     12641        2165        3603\n75108        1801               5559      9702        1565        2846\n75109        2736               7069     19617        3478        4083\n75110        2792              11091     24147        6343        6956\n75111        4078              16834     41433        9858       11984\n75112        3110              17818     34751        8065       12084\n75113        3579              26830     37734       12013       18004\n75114        2833              21803     34451        7799       10691\n75115        5406              33083     61908       11934       18334\n75116        7610              29263     38068        7483       12469\n75117        5507              22483     44533       10295       13820\n75118        5173              26132     43799       13748       19650\n75119        4114              27105     31834       15607       19879\n75120        4372              26471     36741       15451       20449\n92002        1174               7550     14133        2770        5006\n92004        2182              10945     17202        5226        9078\n92007         620               5612      3976        3216        6011\n92009         718               3611      6113        1448        2530\n92012        4082              14403     31656        6128        9720\n92014         328               2936      5186         917        1514\n92019         719               4553      5407        2008        3674\n92020         746               4061      8280        1817        3388\n92022         452               2383      4802         911        1917\n92023        1429               6146      8927        2801        5615\n92024        1202               8388      9841        4630        8015\n92025        2156              12208     12715        5698        9687\n92026        1917               9884     20200        4001        7523\n92032         473               3343      4078        1437        2795\n92033         603               2344      3653         806        1422\n92035         771               3110      6950        1335        2677\n92036         877               7739      2661        4435        6531\n92040        1461               7523     18169        3145        6084\n92044        2105               7096     16792        3331        5410\n92046         568               4306      4989        2052        3797\n92048        1105               5766      8714        2228        4372\n92049         993               5656     11614        2579        4552\n92050        1797              15107     12152        7347       13245\n92051        3093               9177     14478        2648        3784\n92060         509               2970      5771        1226        3231\n92062        1168               5086     11122        2606        4376\n92063        1922               9678     16483        3814        6784\n92064         943               4300      7694        1193        2038\n92071         570               3250      4443         803        1334\n92072         619               2753      5159        1235        2021\n92073        1387               5396     11825        2697        4597\n92075         556               3638      6112        1327        2490\n92076         315               1278      2005         326         490\n92077         268               1566      2465         516         983\n92078         383               4246      1193        2004        3386\n93001        1803              17959      4105        9383       11997\n93005        1825              15462      4347        7498       10384\n93006        1022               5861      3453        2925        4564\n93007        1440              10074      1672        5329        7692\n93008         848              12230      1748        4859        7083\n93010        1186               9569      2401        5114        7288\n93013         380               2417       867        1431        2054\n93014         543               7058       510        2174        3285\n93027        1120               8740      1114        5351        5998\n93029        1908              11751      2701        6932        9906\n93030         152               2004       267        1131        1797\n93031        1006               9637      2592        4599        7650\n93032         883               5250      3412        2649        4994\n93033         180                767      1011         254         667\n93039         122               1355       487         899        1163\n93045         612               2847      3727        1636        2376\n93046        1160               6211      2972        2863        6218\n93047         767               5104      1314        1753        3309\n93048        2424              15246     14691       10062       12278\n93049         608               2444      2933        1224        2525\n93050         665               5486      2203        1982        5805\n93051        1302               9093      7571        4600        8793\n93053         936               7492      2444        3703        6353\n93055        1238               8681      6417        5087        7251\n93057         800               3106      1809        1660        3000\n93059         613               6152      1068        2952        3882\n93061         375               2442      2000        1540        2191\n93062         555               1736      2259         866        1464\n93063         738               4446      2665        2501        3806\n93064         881               6249      3846        3168        6608\n93066        2005              21474      7505       12089       14386\n93070        1149               7621      6161        4841        6377\n93071         936               9139      1751        4729        6760\n93072         805               7476       720        3668        5365\n93073         827               5122      1798        2717        4866\n93074         107                880       424         598         934\n93077         746               4007      3278        1760        3726\n93078         755               6756      1565        3262        5000\n93079         236               2539       309        1375        1997\n94002        1005               6028      5570        3645        5546\n94003         414               3280      3418        1423        2431\n94004         345               2708      1100        1248        2679\n94011         357               2921       794        1580        2722\n94015         470               2136      3191         796        1605\n94016         462               5823      5204        2027        3114\n94017        1808              11605      5828        5328       10405\n94018         836               3466      6067        1476        2778\n94019         485               2375      1425        1211        2387\n94021         408               2918      1558        1027        3008\n94022        1093               6190      4200        3716        6008\n94028        1904              14270      8361        6566       13682\n94033        1139               6421      7810        3394        5843\n94034         415               5565      2788        1388        3981\n94037         397               2797      2585        1432        2351\n94038         593               4300      3990        1932        3772\n94041        1319              10507      7337        5137        7976\n94042         613               2462      3262        1125        2077\n94043         440               3983      4120        1805        3168\n94044         583               3810      1982        1534        3940\n94046        1110               6855      9212        2954        7050\n94048         133                746       681         138         473\n94052         904               3854      7427        1620        2835\n94054         451               3841      1140        1874        3482\n94055         502               1224      1114         411        1058\n94058         974               3563      6406        1597        2947\n94059         536               2172      1950         891        2616\n94060         286               1516       946         588        1805\n94065         112                514       856         262         681\n94067         818               2757      5174        1042        1628\n94068        2431               9265     14149        3056        6692\n94069         405               1803      2589         863        1551\n94071         723               3563      3412        1282        2869\n94073         659               3996      3347        1739        3891\n94074         291               2582       510        1338        2059\n94075         420               1220      1160         480        1305\n94076        1152               9404      5844        4115        6826\n94077         597               2809      1379        1442        2712\n94078         723               6285      1039        2878        5180\n94079         564               4122      3286        1307        3579\n94080        1262               5049     13875        2404        3642\n94081        2118              15797      6440        7232       12788\n      nb_Ouvriers nb_PI nb_Retraités\n75101         362  1607         2595\n75102         647  2566         2140\n75103         667  4174         4539\n75104         556  3277         4466\n75105         913  5239        10496\n75106         629  3112         8032\n75107         878  3791         9369\n75108         836  3053         5190\n75109        1344  6361         7146\n75110        2505 10028        10405\n75111        3767 18948        21357\n75112        3793 17066        24117\n75113        5903 20178        31715\n75114        2998 13834        24067\n75115        4839 23688        40711\n75116        3140 13014        30769\n75117        4405 17450        24274\n75118        8542 24062        25315\n75119        7795 20309        27746\n75120        7962 23883        30579\n92002        1848  6869        11748\n92004        3674 10134        11320\n92007        2576  4719         5645\n92009         985  3613         4308\n92012        2580 13269        19435\n92014         584  2153         3576\n92019        1623  4176         5314\n92020        1017  4789         5712\n92022         561  2489         3358\n92023        1972  6474         9507\n92024        3488  7692         7724\n92025        4440  9453        12087\n92026        1984  9647        12132\n92032         906  2830         4384\n92033         491  1830         3427\n92035         954  3854         4364\n92036        3712  4705         6784\n92040        1513  8107         9707\n92044        1552  7924         9662\n92046        1375  3882         4619\n92048        1758  4902         8338\n92049        1426  6118         7825\n92050        5485  9611        11663\n92051         763  4280        11434\n92060        1039  4089         5000\n92062        1488  5282         6019\n92063        2132  8942        13113\n92064         510  2685         4726\n92071         370  1803         3950\n92072         646  2406         4021\n92073        1459  5708         6232\n92075         741  3481         5087\n92076         156   737         1747\n92077         241  1211         1797\n92078        1840  2087         3347\n93001        9551  6303         7835\n93005        8102  7705        11094\n93006        2634  3738         4850\n93007        5791  4325         7310\n93008        5026  3716         5435\n93010        4683  4422         6933\n93013        1777  1345         2035\n93014        2697  1807         2648\n93027        4966  2694         4229\n93029        6568  6663         9818\n93030         970   881         1034\n93031        4709  4717         6576\n93032        2764  4816         6142\n93033         268  1025         1377\n93039         473   823          940\n93045        1010  2930         4059\n93046        3427  5642         7333\n93047        2289  2747         4014\n93048        6651 12739        15162\n93049        1122  2823         3332\n93050        2714  4214         4839\n93051        4089  8630         9452\n93053        3516  4024         5352\n93055        4665  6539         7049\n93057        1893  3014         3341\n93059        3254  2103         3275\n93061        1159  2070         2480\n93062         508  2070         2442\n93063        1912  3365         3664\n93064        3234  5435         6510\n93066        9844  9196        10940\n93070        3586  5473         4943\n93071        4817  4219         6529\n93072        3634  2606         4155\n93073        3187  4424         5243\n93074         588   970         1050\n93077        2004  3752         4823\n93078        3154  3435         4701\n93079        1122  1103         1549\n94002        2778  5590         6100\n94003        1127  2631         3046\n94004        1302  1742         2320\n94011        1575  1669         2536\n94015         601  2208         3110\n94016        1089  3230         4200\n94017        5696  8885        11280\n94018         800  4110         4882\n94019        1393  2060         3141\n94021        1494  2214         3109\n94022        3388  5711         5977\n94028        5278 10901        12880\n94033        2464  6177         8429\n94034        1496  3780         3676\n94037        1033  2392         2563\n94038        1687  3487         5734\n94041        4141  7194         8641\n94042         630  2435         3565\n94043        1064  2710         3333\n94044        2092  4106         2819\n94046        2366  7643         9925\n94048         232   505         1075\n94052         875  4031         6058\n94054        2176  2456         3092\n94055         599  1199         2468\n94058        1162  4553         6223\n94059        1302  2538         3869\n94060         882  1529         1665\n94065         247   966         1028\n94067         365  2635         4012\n94068        2324  9043        15911\n94069         391  1778         2263\n94071        1417  3182         5774\n94073        1996  3999         5380\n94074        1471  1272         1695\n94075         765  1550         2325\n94076        2877  6417         8768\n94077        2154  2355         3489\n94078        3833  2649         3910\n94079        2009  3520         5204\n94080        1129  6119         7759\n94081        8175  9459        13396",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Clustering : application sur le RP 2019</span>"
    ]
  },
  {
    "objectID": "12-Clustering-application.html#la-méthode-de-la-cah-appliquée-à-nos-données",
    "href": "12-Clustering-application.html#la-méthode-de-la-cah-appliquée-à-nos-données",
    "title": "12  Clustering : application sur le RP 2019",
    "section": "12.2 La méthode de la CAH appliquée à nos données",
    "text": "12.2 La méthode de la CAH appliquée à nos données\n\n12.2.1 Constitution des classes\n\nComme nos communes ont plus d’habitants que d’autres, pour éviter un effet taille de nos communes, on va utiliser la distance du khi-2. Pour cela, deux façons de faire avec deux packages différents : soit le package vegan() et la fonction decostand() avec l’argument method=\"chi.square\" qui crée un tableau sur lequel on applique ensuite la méthode de distance euclidienne et dans ce cas on aura des distinces similaires à celles du khi-2 (voir ici) ; soit le package ade4 et les fonctions combinées dist.dudi(dudi.coa()) avec l’argument amongrow=TRUE (pour préciser que les distances doivent être calculées entre lignes, ici les communes).\n\n# Etape 1 : on transforme la table sur laquelle on obtiendra des distances du khi-deux\n# install.packages(\"vegan\")\nlibrary(vegan)\ncat_soc_chi2 &lt;- decostand(cat_soc, method = \"chi.square\")\n\n# Etape 2 : on crée la matrice de distance, en utilisant la distance euclidienne \n# standard sur la table transformée, ce qui nous donnera des distances similaires \n# à celle du khi-2\ndist_mat &lt;- dist(cat_soc_chi2, method = 'euclidean')\n\n# on peut vérifier qu'on obtient la même matrice avec la seconde méthode évoquée\n# install.packages(\"ade4\")\nlibrary(ade4)\ndist_mat_bis &lt;- dist.dudi(dudi.coa(cat_soc, scannf=FALSE, nf=7), amongrow=TRUE)\n\n# si on souhaite voir et comparer les matrices de distances, \n# on doit les transformer en matrice avec la fonction 'as.matrix' :\ncat_soc_chi2_m &lt;- as.matrix(dist_mat)\ncat_soc_chi2_bis_m &lt;- as.matrix(dist_mat_bis)\n# elles sont bien similaires -&gt; on peut supprimer de l'environnement la seconde\nrm(cat_soc_chi2_bis_m)\n\n\n#Etape 3 : on choisit la méthode d'agrégation, ici la plus standard, le critère de Ward\nclassif_socioprof &lt;- hclust(dist_mat, method = \"ward.D2\")\n\n\n#Etape 4 : on visualise l'arbre de classification ou dendogramme\nplot(classif_socioprof, xlab=\"Commune\",  main=\"Dendogramme\")\n\n\n\n\n\n\n\n# plot(classif_socioprof, xlab=\"Commune\",  main=\"Dendogramme\", labels=FALSE)\n\nOn remarque ici que comme nous avons mis en label le nom des communes, on peut tout de suite savoir quelles communes sont proches et vont former des classes. Toutefois, avec 136 communes ce n’est absolument pas lisible !! Donc on peut aussi les enlever avec l’option label=FALSE dans la fonction plot().\nIl existe aussi une fonction via ggplot2 pour dessiner l’abre, mais il faut installer avant le package ggdendro.\n\nlibrary(ggdendro)\nggdendrogram(classif_socioprof, labels=FALSE)\n\n\n\n\n\n\n\n\nIl faut maintenant prendre une décision : où coupe-t-on l’arbre pour obtenir une partition de la population (ici nos communes), autrement dit combien de classes choisissons-nous ?\nOn peut d’abord s’appuyer sur la forme du dendogramme : plus une “branche” est haute et plus on perd en distance ou ici (critère de Ward) en inertie intraclasse1, il faudra donc couper l’arbre au niveau de cette branche. Il faut également prendre en compte ce qui peut être le mieux pour l’analyse : si on aboutit à une classification en 2 classes, cela risque d’être peu intéressant à analyser, mais si on a une classification en 5 classes ou plus, cela va devenir compliqué à interpréter…\nIci, dans les deux cas, il semble que choisir 2 classes soit très pertinent, mais on voit qu’on pourrait aussi choisir 4 classes (ou même 3 éventuellement) si l’on veut rentrer un peu plus dans le détail de l’analyse.\nOn peut également s’aider de représentations des sauts d’inertie du dendrogramme selon le nombre de classes qui peut être retenu, avec la fonction plot et en récupérant l’information sur l’inertie (height).\n\n# On stocke l'attribut `$height` dans l'objet `inertie` en triant les valeurs par \n# ordre décroissant.\ninertie_socioprof &lt;- sort(classif_socioprof$height, decreasing=TRUE)\nplot(inertie_socioprof, type=\"s\", xlab=\"Nombre de classes\", ylab=\"Inertie\", \n     xlim = c(1,15), xaxp = c(1,15,14))\npoints(c(2, 3, 4), inertie_socioprof[c(2,3,4)], \n       col = c(\"blue3\", \"brown3\", \"chartreuse3\"), cex = 2, lwd = 2)\n\n\n\n\n\n\n\n\nOu encore créer d’autres indicateurs plus rigoureux, comme la part de la perte d’inertie interclasse dans l’inertie totale (on parle aussi de “semi-partial R-squared”).\n\n#on crée un indicateur de part en %\npartinertie_socioprof &lt;- inertie_socioprof/sum(inertie_socioprof)*100\nplot(partinertie_socioprof, type=\"b\", xlab=\"Nombre de classes\", \n     ylab=\"Part dans l'inertie totale en %\", xlim = c(1,15), xaxp = c(1,15,14))\n\n\n\n\n\n\n\n\nOn voit que les graphiques sont assez proches, qu’ils soient construits à partir de la mesure en valeur absolue ou en valeur relative. Il y a un saut important après 2 classes (hauteur sur le 1er graphique, ou importance de la pente sur le 2ème graphique) par exemple.\nEnfin, à savoir que des fonctions existent donnant une indication de la “meilleure” partition à choisir, mais attention le choix se fait aussi (et peut-être surtout) en fonction de l’analyse que l’on veut mener et de l’interprétation que l’on pourra faire des classes obtenues ! Pour l’exemple, je vous mets ci-dessous le code de Julien Larmarange pour tester ce type de fonctions ; la “meilleure” partition selon la perte d’inertie relative est représentée par un point noir et la seconde par un point gris. On voit qu’ici il est bien indiqué d’abord 2 classes, puis comme seconde “meilleure” partition 3 classes, ce qui correspond plutôt bien aux graphiques précédents.\n\nlibrary(devtools)\nsource(url(\"https://raw.githubusercontent.com/larmarange/JLutils/master/R/clustering.R\"))\n#On a choisit un maximum de 15 classes ici...\nbest.cutree(classif_socioprof, min=2, max=15, graph = TRUE, \n            xlab = \"Nombre de classes\", ylab = \"Inertie relative\")\n\n\n\n\n\n\n\n\n[1] 2\n\n\nFinalement, au vu de la forme du dendogramme et des graphes sur l’inertie (et de la fonction d’aide à la décision précédente), on choisit de prendre 4 classes pour une analyse plus fine, mais on va stocker également les résultats pour 3 classes. On peut de nouveau visualiser le dendogramme en matérialisant les différents choix du nombre de classes.\n\npar(mfrow = c(1, 1), mar=c(5, 9, 1, 1))\nplot(classif_socioprof, xlab=\"Commune\",  main=\"Dendogramme\", label=FALSE)\nrect.hclust(classif_socioprof, k=3, border = 'blue3')\nrect.hclust(classif_socioprof, k=4, border = 'brown3')\n\n\n\n\n\n\n\n\nOn peut également utiliser la fonction color_branches() du package dendextend(), mais il faut appeler de nouveau ggplot2 après.\n\n# On peut encore également utiliser la fonction `color_branches()` du package \n# `dendextend()` mais il faut appeler de nouveau `ggplot2` après\nlibrary(dendextend)\nlibrary(ggplot2)\nggplot(color_branches(classif_socioprof, k = 4), labels = FALSE)\n\n\n\n\n\n\n\n\nOn choisit donc d’abord d’analyser notre clustering en 3 ou 4 classes : pour découper l’arbre et obtenir la partition souhaitée, on utilise la fonction cutree(), et on peut ensuite visualiser quelle commune est dans quelle classe et le nombre (et la part) de communes par classe.\nOn intègre ensuite la variable au tableau initial “cat_soc_chi2” qui contient les variables utilisées, mais on pourra ensuite fusionner la table avec notre table initiale “RP_final” pour mener des analyses plus approfondies des classes, y compris avec des variables non utilisées dans le clustering.\n\n#Découpage en k classes\nclasse3_socioprof &lt;- cutree(classif_socioprof, k=3)\nclasse4_socioprof &lt;- cutree(classif_socioprof, k=4)\n\n#Liste des groupes\n#library(janitor)\ntabyl(classe3_socioprof) %&gt;% adorn_pct_formatting() %&gt;% gt()\n\n\n\n\n\n\n\nclasse3_socioprof\nn\npercent\n\n\n\n\n1\n39\n28.7%\n\n\n2\n41\n30.1%\n\n\n3\n56\n41.2%\n\n\n\n\n\n\ntabyl(classe4_socioprof) %&gt;% adorn_pct_formatting() %&gt;% gt()\n\n\n\n\n\n\n\nclasse4_socioprof\nn\npercent\n\n\n\n\n1\n39\n28.7%\n\n\n2\n41\n30.1%\n\n\n3\n28\n20.6%\n\n\n4\n28\n20.6%\n\n\n\n\n\n\nsort(classe4_socioprof) \n\n75101 75102 75103 75104 75105 75106 75107 75108 75109 75110 75111 75112 75114 \n    1     1     1     1     1     1     1     1     1     1     1     1     1 \n75115 75116 75117 92002 92012 92014 92020 92022 92026 92035 92040 92044 92049 \n    1     1     1     1     1     1     1     1     1     1     1     1     1 \n92051 92062 92063 92064 92071 92072 92073 92075 92076 92077 94052 94067 94080 \n    1     1     1     1     1     1     1     1     1     1     1     1     1 \n75113 75118 75119 75120 92004 92009 92019 92023 92024 92025 92032 92033 92046 \n    2     2     2     2     2     2     2     2     2     2     2     2     2 \n92048 92060 93033 93045 93049 93062 93077 94003 94015 94016 94018 94033 94037 \n    2     2     2     2     2     2     2     2     2     2     2     2     2 \n94038 94042 94043 94046 94048 94055 94058 94059 94065 94068 94069 94071 94073 \n    2     2     2     2     2     2     2     2     2     2     2     2     2 \n94075 94079 92007 92050 93006 93032 93046 93048 93050 93051 93055 93057 93061 \n    2     2     3     3     3     3     3     3     3     3     3     3     3 \n93063 93064 93070 93073 93074 94002 94017 94019 94021 94022 94028 94034 94041 \n    3     3     3     3     3     3     3     3     3     3     3     3     3 \n94044 94060 94076 94077 92036 92078 93001 93005 93007 93008 93010 93013 93014 \n    3     3     3     3     4     4     4     4     4     4     4     4     4 \n93027 93029 93030 93031 93039 93047 93053 93059 93066 93071 93072 93078 93079 \n    4     4     4     4     4     4     4     4     4     4     4     4     4 \n94004 94011 94054 94074 94078 94081 \n    4     4     4     4     4     4 \n\n#Ajout des variables de classe dans la table initiale de clustering : on ne crée qu'une\n# seule table qui aura nos 2 variables de typo selon 3 ou 4 classes\nclust_socioprof &lt;- cbind.data.frame(cat_soc_chi2, classe3_socioprof=as.factor(classe3_socioprof))\nclust_socioprof &lt;- cbind.data.frame(clust_socioprof, classe4_socioprof=as.factor(classe4_socioprof))\n\nLa 1ère classe comprend donc 39 communes soit 29% de l’ensemble des communes de Paris et sa petite couronne, la 2ème classe 41 communes ou 30%, et la 3ème classe rassemble 56 communes soit 41% lorsqu’elle est agrégée et sinon se divive en deux classes de même nombre (28 et 28) ou proportion dans la partition à 4 classes. La dernière sortie nous donne la place de chaque commune dans chacune des 4 classes, mais ce n’est pas super lisible comme cela.\n\n\n12.2.2 Visualisation sur la carte des communes et départements\nEnfin, on peut visualiser sur la carte des communes et départements les quatre classes construites et choisies.\n\n#library(geojsonsf)\nlibrary(sf)\nlibrary(mapsf)\n\n# on charge le fonds de carte des communes -&gt; vous pouvez reprendre les tables utilisées dans le cours de Claude Grasland, sinon la télécharger sur opendatasoft\n# map_com &lt;- geojson_sf(\"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/geoflar-communes-2015/exports/geojson?lang=fr&refine=nom_reg%3A%22ILE-DE-FRANCE%22&timezone=Europe%2FBerlin\")\nmap_com &lt;- readRDS(\"data/map_com.RDS\")\nmap_com &lt;- map_com %&gt;% \n  rename(COM=com_code) %&gt;% \n  mutate(COM=as.character(COM))\nmap_dept &lt;- map_com %&gt;% group_by(dep_code, dep_name) %&gt;% \n                  summarise()\n# si ajout contours établissements publics territoriaux (EPT)\n# map_ept &lt;- readRDS(\"data/map_ept.RDS\")\n\ntypo3 &lt;- clust_socioprof %&gt;% rownames_to_column(var = \"COM\") %&gt;% \n  select(COM, classe3_socioprof)\nmap_com_typo3 &lt;- map_com %&gt;% select(COM, com_name, geometry) %&gt;% \n  left_join(typo3)\nmf_theme(\"agolalight\")\nmf_map(map_com_typo3, var=\"classe3_socioprof\", type=\"typo\", \n       pal = c(\"aquamarine3\", \"coral\", \"skyblue3\"),\n       leg_pos = \"bottomleft\", leg_title=\"Cluster\",\n       col_na = \"gray80\", leg_no_data = \"Données manquantes\")\nmf_map(map_dept, var=\"nom_dep\",  type = \"base\",\n       col = NA, col_na = \"gray80\",\n       border=\"black\",lwd=1, add = TRUE)\nmf_layout(title = \"Profils PCS des communes de Paris et sa petite couronne\",\n          frame = TRUE, credits=\" \", arrow = F)\n\n\n\n\n\n\n\ntypo4 &lt;- clust_socioprof %&gt;% rownames_to_column(var = \"COM\") %&gt;% \n  select(COM, classe4_socioprof)\nmap_com_typo4 &lt;- map_com %&gt;% select(COM, com_name, geometry) %&gt;% \n  left_join(typo4)\nmf_theme(\"agolalight\")\nmf_map(map_com_typo4, var=\"classe4_socioprof\", type=\"typo\", \n       pal = c(\"aquamarine3\", \"coral\", \"skyblue3\", \"brown4\"),\n       leg_pos = \"bottomleft\", leg_title=\"Cluster\",\n       col_na = \"gray80\", leg_no_data = \"Données manquantes\")\n# mf_map(map_ept, var=\"ept_name\",  type = \"base\",\n#        col = NA, col_na = \"gray80\",\n#        border=\"blue\",lwd=1, add = TRUE)\nmf_map(map_dept, var=\"nom_dep\",  type = \"base\",\n       col = NA, col_na = \"gray80\",\n       border=\"black\",lwd=1, add = TRUE)\nmf_layout(title = \"Profils PCS des communes de Paris et sa petite couronne\",\n          frame = TRUE, credits=\" \", arrow = F)\n\n\n\n\n\n\n\n\nOn voit avec la seconde carte que la partition en 4 classes permet de préciser le clustering en particulier pour les communes du département de Seine-St-Denis. On va retenir définitivement cette partition en 4 classes pour l’interprétation.\n\n\n12.2.3 Interprétation\nIl faut maintenant comprendre la partition obtenue et interpréter nos 4 classes en les décrivant principalement ici à partir des variables utilisées dans le clustering. On peut pour cela utiliser le package FactoMineR qui permet avec la fonction catdes de sortir des résultats sur, d’une part, les liens les plus significatifs entre les variables actives de la CAH et la variable globale de cluster/classes, et, d’autre part de manière plus précise, sur les liens les plus significatifs entre les variables et chacune des classes. De manière générale, le package FactoMineR est presque indispensable pour toute analyse factorielle de données et/ou clustering (voir ici).\n\nlibrary(FactoMineR)\n# on retire la variable de classe qui ne nous intéresse pas (la type en 3 classes ici)\ncatdes(clust_socioprof[, -9], num.var = 9)\n\n\nLink between the cluster variable and the quantitative variables\n================================================================\n                        Eta2      P-value\nnb_Cadres          0.9075190 5.051344e-68\nnb_Ouvriers        0.8691562 4.369492e-58\nnb_Employés        0.8304926 1.125821e-50\nnb_Chômeurs        0.7194329 2.916476e-36\nnb_Autres.inactifs 0.6262392 4.530630e-28\nnb_PI              0.4836017 7.367933e-19\nnb_Retraités       0.3360390 9.898185e-12\nnb_Arti_com        0.2180956 3.920464e-07\n\nDescription of each cluster by quantitative variables\n=====================================================\n$`1`\n                      v.test Mean in category Overall mean sd in category\nnb_Cadres           9.230631        0.6634648    0.3984220     0.05880146\nnb_Arti_com         5.077079        0.2140143    0.1772711     0.06795860\nnb_PI              -2.306082        0.3535017    0.3736918     0.05635525\nnb_Autres.inactifs -4.054787        0.3745396    0.4253899     0.06096658\nnb_Chômeurs        -5.972422        0.2115313    0.2844051     0.03021788\nnb_Ouvriers        -8.016067        0.1146623    0.2744024     0.02567630\nnb_Employés        -8.936187        0.2633226    0.3842266     0.03755561\n                   Overall sd      p.value\nnb_Cadres          0.21154267 2.690426e-20\nnb_Arti_com        0.05331831 3.832822e-07\nnb_PI              0.06450243 2.110606e-02\nnb_Autres.inactifs 0.09239296 5.018006e-05\nnb_Chômeurs        0.08989471 2.337566e-09\nnb_Ouvriers        0.14681341 1.091849e-15\nnb_Employés        0.09967854 4.028297e-19\n\n$`2`\n                      v.test Mean in category Overall mean sd in category\nnb_Retraités        5.082473        0.4869929    0.4357343     0.07511809\nnb_PI               4.885737        0.4149784    0.3736918     0.04466321\nnb_Ouvriers        -2.682174        0.2228135    0.2744024     0.05872551\nnb_Chômeurs        -3.677228        0.2410982    0.2844051     0.05158555\nnb_Autres.inactifs -4.130110        0.3753976    0.4253899     0.04916426\n                   Overall sd      p.value\nnb_Retraités       0.07698186 3.725522e-07\nnb_PI              0.06450243 1.030429e-06\nnb_Ouvriers        0.14681341 7.314544e-03\nnb_Chômeurs        0.08989471 2.357823e-04\nnb_Autres.inactifs 0.09239296 3.625898e-05\n\n$`3`\n               v.test Mean in category Overall mean sd in category Overall sd\nnb_Employés  4.935740        0.4673877    0.3842266     0.04304196 0.09967854\nnb_PI        3.618256        0.4131413    0.3736918     0.03912118 0.06450243\nnb_Ouvriers  3.596816        0.3636609    0.2744024     0.05800568 0.14681341\nnb_Chômeurs  2.306199        0.3194478    0.2844051     0.05270552 0.08989471\nnb_Arti_com -2.107284        0.1582793    0.1772711     0.02962413 0.05331831\nnb_Cadres   -4.040794        0.2539344    0.3984220     0.05845409 0.21154267\n                 p.value\nnb_Employés 7.984729e-07\nnb_PI       2.965946e-04\nnb_Ouvriers 3.221364e-04\nnb_Chômeurs 2.109949e-02\nnb_Arti_com 3.509293e-02\nnb_Cadres   5.327051e-05\n\n$`4`\n                      v.test Mean in category Overall mean sd in category\nnb_Autres.inactifs  8.744175        0.5619500    0.4253899     0.07117056\nnb_Chômeurs         8.547157        0.4142790    0.2844051     0.05537340\nnb_Ouvriers         8.413011        0.4831796    0.2744024     0.06607172\nnb_Employés         6.594694        0.4953390    0.3842266     0.03801306\nnb_Arti_com        -3.049291        0.1497896    0.1772711     0.02382982\nnb_Retraités       -5.374273        0.3658026    0.4357343     0.04702790\nnb_PI              -6.583845        0.3019088    0.3736918     0.03950428\nnb_Cadres          -7.743861        0.1215229    0.3984220     0.03903016\n                   Overall sd      p.value\nnb_Autres.inactifs 0.09239296 2.246510e-18\nnb_Chômeurs        0.08989471 1.261573e-17\nnb_Ouvriers        0.14681341 3.996168e-17\nnb_Employés        0.09967854 4.261338e-11\nnb_Arti_com        0.05331831 2.293824e-03\nnb_Retraités       0.07698186 7.689216e-08\nnb_PI              0.06450243 4.584360e-11\nnb_Cadres          0.21154267 9.644260e-15\n\n\nOn peut voir que la 1ère classe est marquée par une surreprésentation du nombre de personnes (de référence du ménage) cadres, puis artisans-commerçants ; et au contraire, une sous-représentation des employés, ouvriers, chômeurs ou encore autres inactifs. Sur la carte, on avait vu que cette classe était présente dans 16 des 20 arrondissements de Paris, ainsi que dans des communes des Hauts-de-Seine. C’est donc la classe correspond aux communes des catégories d’actifs en emploi plutôt favorisées.\n  La seconde classe est, elle, caractérisée par une surreprésentation du nombre de retraités et de professions intermédiaires, et par une sous-représentation du nombte d’autres inactifs, chômeurs et ouvriers. Géographiquement, on avait vu qu’elle correspondait aux 4 autres arrondissements de Paris et à des communes disséminées surtout dans les Hauts-de-Seine et le Val-de-Marne. Cette classe pourraient correspondre à des classes moyennes supérieures soient en emploi (professions intermédiaires) soient à la retraite.\n  Dans la troisième classe, on note une surreprésentation des employés, des professions intermédiaires, des ouvriers et des chômeurs, et au contraire une sous-représentation des cadres et artisans-commerçants. Elle semble ainsi à l’opposé de la 1ère classe. Elle est davantage présente dans les communes du Val-de-Marne et de la Seine-Saint-Denis. Cette troisième classe correspond probablement ainsi à des catégories sociales moyennes basses, voire à des défavorisées.   Enfin, la quatrième classe se caractérise par une surreprésentation des autres inactifs, des chômeurs, des ouvriers et des employés. Elle se retrouve plutôt dans les communes de la Seine-Saint-Denis, et un peu dans le Val-de-Marne. Elle correspondrait alors aux catégories sociales les plus défavorisées.\nOn peut recupérer les statistiques de la moyenne de ces variables pour les visualiser sur un graphique comparant les 3 classes, ainsi que l’ensemble des communes, on va plutôt le faire à partir des variables centrées réduites, ce qui permet une une comparaison directe des profils de classe à partir de variables dont l’ordre de grandeur (l’écart-type) peut être différent.\n\n# La fonction `scale()` permet de normaliser par colonne les valeurs numériques\nclust_socioprof_sc &lt;- as.data.frame(scale(clust_socioprof[, -c(9, 10)])) \nclust_socioprof_1 &lt;- cbind.data.frame(clust_socioprof_sc, \n                                      classe=as.factor(classe4_socioprof))\n\nmean_var &lt;- clust_socioprof_1 %&gt;% group_by(classe) %&gt;% \n    summarise_all(list(mean))\n\nmean_var %&gt;% pivot_longer(cols=-classe, names_to=\"Variable\", values_to=\"Value\") %&gt;% \n  ggplot() + aes(x=Variable, y=Value, fill=classe) + geom_bar(stat=\"identity\") +\n  facet_wrap(~classe) +  scale_fill_brewer(palette = \"Set2\") +\n  theme_grey() + coord_flip() +\n  labs(title = \"Moyenne des variables actives selon les classes\",\n       x=\"Variables\", y=\"\") +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nCela nous dit la même chose que la description précédente mais dans un format plus visuelle.\nPour aller plus loin dans la compréhension des classes, il faut utiliser d’autres variables et procéder de même à des analyses descriptives croisant ces variables avec les 4 classes de la typologie obtenue. Pour cela, il faut récupérer des variables de la table initiale du RP et sortir des tableaux de statistiques ou des graphiques comme précédemment. \n\n# Pour d'autres variables, tableau croisé en pourcentage à partir d'une nouvelle\n# fonction\nTabcr_pctcol &lt;- function(data, var1, var2, pond=IPONDI, nom_var1=\"classe\"){\n  tabcroisefin &lt;- data %&gt;% group_by({{var2}})  %&gt;% \n    count({{var1}}, wt={{pond}}) %&gt;% pivot_wider(names_from = {{var1}},\n                                                 values_from = \"n\", \n                                                 names_prefix = paste0(nom_var1,\"_\")) %&gt;% \n    adorn_totals(c(\"row\",'col')) %&gt;% adorn_percentages(\"col\") %&gt;% \n    adorn_pct_formatting(digits=2) \n  \n  return(tabcroisefin)\n}\n\nclust_socioprof &lt;- clust_socioprof %&gt;% rownames_to_column(var=\"COM\")\n\n# Liste variable à étudier plus en détails par exemple: \"HLML\",\"AGER20\", \"DIPL\", IMMI,\n# \"EMPL\", \"RECH\",  \"STAT_CONJ\", \"STOCD\",  \"TACTD16\", \"TP\",  \"TYPL\", \"ETUD\", SURF, CATL\nclust_socioprof %&gt;% left_join(RP_final[RP_final$CS1!=\"1\" & \n                                         RP_final$COM!=\"ZZZZZ\" & \n                                         !RP_final$AGER20 %in% c(\"2\",\"5\",\"10\",\"14\"),\n                                       c(\"COM\", \"IPONDI\", \"DIPL\")],\n                                   by=\"COM\") %&gt;% \n  libelles_var(cod_var=\"DIPL\", new_var = Diplome_nom) %&gt;%  \n  Tabcr_pctcol(var1=classe4_socioprof, var2=Diplome_nom) %&gt;% gt()\n\n\n\n\n\n\n\nDiplome_nom\nclasse_1\nclasse_2\nclasse_3\nclasse_4\nTotal\n\n\n\n\nPas de scolarité ou arrêt avant la fin du primaire\n1.51%\n3.06%\n4.56%\n8.24%\n3.62%\n\n\nAucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\n2.29%\n3.90%\n5.67%\n8.93%\n4.46%\n\n\nAucun diplôme et scolarité jusqu’à la fin du collège ou au-delà\n3.01%\n4.54%\n6.59%\n9.78%\n5.21%\n\n\nCEP (certificat d’études primaires)\n2.48%\n3.76%\n4.46%\n4.54%\n3.54%\n\n\nBEPC, brevet élémentaire, brevet des collèges, DNB\n6.04%\n7.39%\n8.24%\n9.00%\n7.31%\n\n\nCAP, BEP ou diplôme de niveau équivalent\n7.16%\n12.02%\n16.42%\n17.35%\n11.90%\n\n\nBaccalauréat général ou technologique, brevet supérieur, capacité en droit, DAEU, ESEU\n11.37%\n11.75%\n12.24%\n11.90%\n11.72%\n\n\nBaccalauréat professionnel, brevet professionnel, de technicien ou d’enseignement, diplôme équivalent\n3.66%\n5.43%\n6.95%\n7.28%\n5.36%\n\n\nBTS, DUT, Deug, Deust, diplôme de la santé ou du social de niveau bac+2, diplôme équivalent\n8.49%\n10.14%\n10.13%\n8.11%\n9.19%\n\n\nLicence, licence pro, maîtrise, diplôme équivalent de niveau bac+3 ou bac+4\n15.80%\n13.86%\n11.11%\n7.58%\n13.04%\n\n\nMaster, DEA, DESS, diplôme grande école niveau bac+5, doctorat de santé\n35.20%\n22.10%\n12.57%\n6.71%\n22.68%\n\n\nDoctorat de recherche (hors santé)\n3.00%\n2.04%\n1.05%\n0.57%\n1.97%\n\n\nTotal\n100.00%\n100.00%\n100.00%\n100.00%\n100.00%\n\n\n\n\n\n\n\nEnfin, on a vu qu’il y avait plusieurs méthodes d’agrégation, ici nous avons utilisé le critère de Ward. Il est possible de tester d’autres méthodes et de comparer les dendogrammes alors obtenus.\n\n#Etape 3 bis : on choisit d'autres méthodes d'agrégation\nclassif.s &lt;- hclust(dist_mat, method = \"single\")\nclassif.c &lt;- hclust(dist_mat, method = \"complete\")\nclassif.a &lt;- hclust(dist_mat, method = \"average\")\nclassif.cd &lt;- hclust(dist_mat, method = \"centroid\")\n\n#Etape 4 bis : on visualise les dendogrammes des 4 nouvelles méthodes + la 1ère utilisée précédemment, et on les compare sur un même graphique\npar(mfrow = c(2, 3))\nplot(classif.s, xlab=\"Commune\", main = \"Single\", label=FALSE)\nplot(classif.c, xlab=\"Commune\", main = \"Complete\", label=FALSE)\nplot(classif.a, xlab=\"Commune\", main = \"Average\", label=FALSE)\nplot(classif.cd, xlab=\"Commune\", main = \"Centroid\", label=FALSE)\nplot(classif_socioprof, xlab=\"Commune\", main = \"Ward\", label=FALSE)\n#par(mfrow = c(1, 1)\n\n\n\n\n\n\n\n\nOn observe donc de fortes différences entre les dendogrammes. Par exemple, la méthode du “lien simple” ou “minimum” va avoir tendance à construire une grosse classe et une autre plus petite, c’est bien ce que l’on voit ici ; alors qu’au contraire, la méthode d’agrégation dite “complete” tend à construire des groupes plutôt de taille égale, en revanche, il faut savoir qu’elle est sensible aux points aberrants (on voit que ce n’est pas le cas ici). Enfin, on voit également que la méthode du “centroïd” (barycentre/centre de gravité des classes) produit un dendogramme particulier et déséquilibré comme le premier graphe (méthode du “lien simple”). C’est bien la méthode de Ward qui est la plus utilisée en pratique.",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Clustering : application sur le RP 2019</span>"
    ]
  },
  {
    "objectID": "12-Clustering-application.html#la-méthode-des-k-means-appliquée-à-nos-données",
    "href": "12-Clustering-application.html#la-méthode-des-k-means-appliquée-à-nos-données",
    "title": "12  Clustering : application sur le RP 2019",
    "section": "12.3 La méthode des k-means appliquée à nos données",
    "text": "12.3 La méthode des k-means appliquée à nos données\nOn repart de notre table de données transformée (“cat_soc_chi2”) et on lui applique la fonction kmeans de R. Comme décrit dans la section précédente de manière théorique, il faut : i) choisir le nombre de classes que l’on souhaite avoir avec l’option centers=k, pour pouvoir comparer avec la méthode précédente de la CAH, on va donc choisir le même nombre de groupe, soit 4 ; ii) et réitérer toute la procédure plusieurs fois avec des individus pris au départ qui soient différents, avec l’option nstart=, ici on choisit 100 essais, et la fonction prendra le meilleur pour l’algorithme.\n\nclust.kmeans &lt;- kmeans(cat_soc_chi2, centers=4, nstart=100)\n\n# On affiche ensuite les résultats principaux : effectif des classes, moyenne des \n# variables actives, groupes d'affectation des individus, \n# proportion d'inertie expliquée par la partition (ici 62%)\nclust.kmeans\n\nK-means clustering with 4 clusters of sizes 26, 35, 33, 42\n\nCluster means:\n  nb_Arti_com nb_Autres inactifs nb_Cadres nb_Chômeurs nb_Employés nb_Ouvriers\n1   0.1495512          0.5676564 0.1166422   0.4207642   0.4941888   0.4881346\n2   0.1581992          0.4296114 0.2578518   0.3090005   0.4645667   0.3610936\n3   0.1742342          0.3735899 0.4404954   0.2416735   0.3630235   0.2120586\n4   0.2127105          0.3745023 0.6569413   0.2130710   0.2658643   0.1188337\n      nb_PI nb_Retraités\n1 0.2981977    0.3623884\n2 0.4116066    0.4216620\n3 0.4154235    0.4903174\n4 0.3560413    0.4499791\n\nClustering vector:\n75101 75102 75103 75104 75105 75106 75107 75108 75109 75110 75111 75112 75113 \n    4     4     4     4     4     4     4     4     4     4     4     4     3 \n75114 75115 75116 75117 75118 75119 75120 92002 92004 92007 92009 92012 92014 \n    4     4     4     4     4     3     3     4     3     2     4     4     4 \n92019 92020 92022 92023 92024 92025 92026 92032 92033 92035 92036 92040 92044 \n    3     4     4     3     3     3     4     3     4     4     1     4     4 \n92046 92048 92049 92050 92051 92060 92062 92063 92064 92071 92072 92073 92075 \n    3     3     4     2     4     3     4     4     4     4     4     4     4 \n92076 92077 92078 93001 93005 93006 93007 93008 93010 93013 93014 93027 93029 \n    4     4     1     1     1     2     1     1     1     1     1     1     1 \n93030 93031 93032 93033 93039 93045 93046 93047 93048 93049 93050 93051 93053 \n    1     1     2     3     1     3     2     1     2     3     2     2     1 \n93055 93057 93059 93061 93062 93063 93064 93066 93070 93071 93072 93073 93074 \n    2     2     1     2     3     2     2     1     2     1     1     2     2 \n93077 93078 93079 94002 94003 94004 94011 94015 94016 94017 94018 94019 94021 \n    2     1     1     2     3     2     1     3     3     2     3     2     2 \n94022 94028 94033 94034 94037 94038 94041 94042 94043 94044 94046 94048 94052 \n    2     2     3     2     2     3     2     3     3     2     3     3     4 \n94054 94055 94058 94059 94060 94065 94067 94068 94069 94071 94073 94074 94075 \n    1     3     3     2     2     3     4     3     3     3     2     1     3 \n94076 94077 94078 94079 94080 94081 \n    2     2     1     2     4     2 \n\nWithin cluster sum of squares by cluster:\n[1] 0.4950321 0.6789536 0.7875165 0.9539909\n (between_SS / total_SS =  79.7 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n\n\nOn peut comparer avec les classes obtenues précédemment avec la CAH, simplement en croisant les deux variables de classe :\n\n#correspondance avec les groupes de la CAH\ntable(classe4_socioprof, clust.kmeans$cluster)\n\n                 \nclasse4_socioprof  1  2  3  4\n                1  0  0  0 39\n                2  0  5 33  3\n                3  0 28  0  0\n                4 26  2  0  0\n\n\nOn voit ainsi que certaines classes de la CAH (les 4 lignes du tableau) coïncident exactement ou quasi-exactement avec les classes des K-means (en colonne), et une un peu moins car un peu plus distribuée entre plusieurs classes de la typologie des K-means . Autrement dit, on conclut à un changement de classes à la marge.\n\nclust_kmeans &lt;- clust.kmeans$cluster %&gt;% as.data.frame() %&gt;% rename(\"classe4_socioprof\"=\".\") %&gt;% rownames_to_column(\"COM\")\n\nmap_com_typo_1 &lt;- map_com %&gt;% select(COM, com_name, geometry) %&gt;% \n  left_join(clust_kmeans)\nmf_theme(\"agolalight\")\nmf_map(map_com_typo_1, var=\"classe4_socioprof\", type=\"typo\", \n       pal = c(\"aquamarine3\", \"coral\", \"skyblue3\", \"brown4\"),\n       leg_pos = \"bottomleft\", leg_title=\"Cluster\",\n       col_na = \"gray80\", leg_no_data = \"Données manquantes\")\nmf_map(map_dept, var=\"nom_dep\",  type = \"base\",\n       col = NA, col_na = \"gray80\",\n       border=\"black\",lwd=1, add = TRUE)\nmf_layout(title = \"Profils PCS des communes de Paris et sa petite couronne\",\n          frame = TRUE, credits=\" \", arrow = F)\n\n\n\n\n\n\n\n\nOn a vu avec la description de la méthode, que ce qui est difficile ici c’est qu’on choisit nous-mêmes le nombre de classes dans une première étape sans savoir parfois pourquoi. Il faut donc souvent faire varier le nombre de classes de départ (centers=k), à ne pas confondre avec les individus centres initiaux de classes (ce que l’on a fait précédemment en indiquant l’option nstart=100). A partir d’un exemple de code récupéré sur un document de cours externe (ici), on peut créer une boucle pour répéter la procédure en changeant le nombre de classes, et ensuite construire un graphique visualisant l’indicateur de pourcentage d’inertie expliquée. Plus précisément, on fait tourner plusieurs fois la méthode des K-means sur notre base de données centrées-réduites pour un nombre de classes souhaitées variant entre 2 et 6, et on récupère la part de l’inertie expliquée par la partition obtenue (indicateur between_SS / total_SS que l’on a vu dans la sortie précédente). Puis, on crée un graphique représentant cette part pour chacune des partitions construites.\n\n# Boucle pour calculer la part de l'inertie expliquée par la partition, selon le  \n# nombre de classes souhaitées\ninertie.expl &lt;- rep(0, times=6)\nfor (k in 2:6){\n  clus &lt;- kmeans(cat_soc_chi2, centers=k, nstart=100)  \n  inertie.expl[k] &lt;- clus$betweenss/clus$totss}\n\n#Création du graphique\nplot(1:6, inertie.expl, type=\"b\", xlab=\"Nombre de classes choisies\", \n     ylab=\"Pourcentage d'inertie expliquée par la partition\")\n\n\n\n\n\n\n\n\nOn observe sur ce graphique qu’à partir de k=3, autrement dit de 3 classes, la “création” d’une classe supplémentaire ne semble pas augmenter significativement la part d’inertie expliquée par la partition. Pour comprendre ce que revêt ce “significativement”, on peut regarder notamment la pente de chaque droite reliant les points d’une partition à une autre : pour la droite reliant le nombre de classes “2” et “3”, on voit que sa pente diminue déjà pas mal par rapport à la droite reliant les deux classes précédentes, et cela est encore plus visible pour les pentes suivantes.\nUne autre méthode évoquée par le même document de cours propose d’utiliser le package fpc qui propose une fonction kmeansruns évaluant les différentes partitions à partir de 2 critères à choisir : l’indice de Calinski Harabasz - option criterion=\"ch\", ou celui de la “average silhouette width” (largeur moyenne de la silhouette) - option criterion=\"asw\". On peut ensuite construire un graphique comme précédemment pour visualiser l’évolution de cet indice selon le nombre de classes de la partition.\n\n# OU utilisation du package fpc et de l'indice de Calinski Harabasz  \nlibrary(fpc)\n#Evaluation des solutions\neval.kmeans &lt;- kmeansruns(cat_soc_chi2,\n                         krange=2:6,\n                         criterion=\"ch\",)\n\n#Graphique\nplot(1:6, eval.kmeans$crit,type=\"b\", xlab=\"Nombre de classes\", \n     ylab=\"Indice de Calinski Harabasz \")\n\n\n\n\n\n\n\n\nPour lire et choisir le “bon” nombre de classes selon ce critère, il faut maximiser l’indice donc trouver le point le plus haut : ici, c’est la partition à 2 classes qui semble la “meilleure” typologie comme on l’avait vu dans la CAH avec le dendogramme, mais une partition a minima en 3 classes semble plus intéressante pour l’interprétation.",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Clustering : application sur le RP 2019</span>"
    ]
  },
  {
    "objectID": "12-Clustering-application.html#footnotes",
    "href": "12-Clustering-application.html#footnotes",
    "title": "12  Clustering : application sur le RP 2019",
    "section": "",
    "text": "Plus précisément, à chaque étape d’agrégation, la part de l’inertie interclasse passe en inertie intraclasse.↩︎",
    "crumbs": [
      "Séance 6",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Clustering : application sur le RP 2019</span>"
    ]
  }
]